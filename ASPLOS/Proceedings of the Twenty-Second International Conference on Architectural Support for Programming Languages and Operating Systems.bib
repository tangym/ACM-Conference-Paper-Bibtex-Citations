@article{Hsiao:2017:ASI:3093337.3037712,
 abstract = {Asynchronous programming model is commonly used in mobile systems and Web 2.0 environments. Asynchronous race detectors use algorithms that are an order of magnitude performance and space inefficient compared to conventional data race detectors. We solve this problem by identifying and addressing two important problems in reasoning about causality between asynchronous events. Unlike conventional signal-wait operations, establishing causal order between two asynchronous events is fundamentally more challenging as there is no common handle they operate on. We propose a new primitive named AsyncClock that addresses this problem by explicitly tracking causally preceding events, and show that AsyncClock can handle a wide variety of asynchronous causality models. We also address the important scalability problem of efficiently identifying heirless events whose metadata can be reclaimed. We built the first single-pass, non-graph-based Android race detector using our algorithm and applied it to find errors in 20 popular applications. Our tool incurs about 6x performance overhead, which is several times more efficient than the state-of-the-art solution. It also scales well with the execution length. We used our tool to find 147 previously unknown harmful races.},
 acmid = {3037712},
 address = {New York, NY, USA},
 author = {Hsiao, Chun-Hung and Narayanasamy, Satish and Khan, Essam Muhammad Idris and Pereira, Cristiano L. and Pokam, Gilles A.},
 doi = {10.1145/3093337.3037712},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {android, asynchronous, causality, data races, event-driven, happens-before},
 link = {http://doi.acm.org/10.1145/3093337.3037712},
 month = {apr},
 number = {1},
 numpages = {13},
 pages = {193--205},
 publisher = {ACM},
 title = {AsyncClock: Scalable Inference of Asynchronous Event Causality},
 volume = {45},
 year = {2017}
}


@inproceedings{Liu:2017:DBD:3037697.3037714,
 abstract = {Emerging non-volatile memory (NVM) offers non-volatility, byte-addressability and fast access at the same time. To make the best use of these properties, it has been shown by empirical evidence that programs should access NVM directly through CPU load and store instructions, so that the overhead of a traditional file system or database can be avoided. Thus, durable transactions become a common choice of applications for accessing persistent memory data in a crash consistent manner. However, existing durable transaction systems employ either undo logging, which requires a fence for every memory write, or redo logging, which requires intercepting all memory reads within transactions. This paper presents DUDETM, a crash-consistent durable transaction system that avoids the drawbacks of both undo logging and redo logging. DUDETM uses shadow DRAM to decouple the execution of a durable transaction into three fully asynchronous steps. The advantage is that only minimal fences and no memory read instrumentation are required. This design also enables an out-of-the-box transactional memory (TM) to be used as an independent component in our system. The evaluation results show that DUDETM adds durability to a TM system with only 7.4 ~ 24.6% throughput degradation. Compared to the existing durable transaction systems, DUDETM provides 1.7times to 4.4times higher throughput. Moreover, DUDETM can be implemented with existing hardware TMs with minor hardware modifications, leading to a further 1.7times speedup.},
 acmid = {3037714},
 address = {New York, NY, USA},
 author = {Liu, Mengxing and Zhang, Mingxing and Chen, Kang and Qian, Xuehai and Wu, Yongwei and Zheng, Weimin and Ren, Jinglei},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037714},
 isbn = {978-1-4503-4465-4},
 keyword = {emerging memory technologies, storage systems, transactional memory},
 link = {http://doi.acm.org/10.1145/3037697.3037714},
 location = {Xi'an, China},
 numpages = {15},
 pages = {329--343},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {DudeTM: Building Durable Transactions with Decoupling for Persistent Memory},
 year = {2017}
}


@article{Park:2017:DRM:3093337.3037707,
 abstract = {As graphics processing units (GPUs) are broadly adopted, running multiple applications on a GPU at the same time is beginning to attract wide attention. Recent proposals on multitasking GPUs have focused on either spatial multitasking, which partitions GPU resource at a streaming multiprocessor (SM) granularity, or simultaneous multikernel (SMK), which runs multiple kernels on the same SM. However, multitasking performance varies heavily depending on the resource partitions within each scheme, and the application mixes. In this paper, we propose GPU Maestro that performs dynamic resource management for efficient utilization of multitasking GPUs. GPU Maestro can discover the best performing GPU resource partition exploiting both spatial multitasking and SMK. Furthermore, dynamism within a kernel and interference between the kernels are automatically considered because GPU Maestro finds the best performing partition through direct measurements. Evaluations show that GPU Maestro can improve average system throughput by 20.2% and 13.9% over the baseline spatial multitasking and SMK, respectively.},
 acmid = {3037707},
 address = {New York, NY, USA},
 author = {Park, Jason Jong Kyu and Park, Yongjun and Mahlke, Scott},
 doi = {10.1145/3093337.3037707},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {graphics processing unit, multitasking, resource management},
 link = {http://doi.acm.org/10.1145/3093337.3037707},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {527--540},
 publisher = {ACM},
 title = {Dynamic Resource Management for Efficient Utilization of Multitasking GPUs},
 volume = {45},
 year = {2017}
}


@inproceedings{Kanev:2017:MAM:3037697.3037736,
 abstract = {Recent work shows that dynamic memory allocation consumes nearly 7% of all cycles in Google datacenters. With the trend towards increased specialization of hardware, we propose Mallacc, an in-core hardware accelerator designed for broad use across a number of high-performance, modern memory allocators. The design of Mallacc is quite different from traditional throughput-oriented hardware accelerators. Because memory allocation requests tend to be very frequent, fast, and interspersed inside other application code, accelerators must be optimized for latency rather than throughput and area overheads must be kept to a bare minimum. Mallacc accelerates the three primary operations of a typical memory allocation request: size class computation, retrieval of a free memory block, and sampling of memory usage. Our results show that malloc latency can be reduced by up to 50% with a hardware cost of less than 1500 um2 of silicon area, less than 0.006% of a typical high-performance processor core.},
 acmid = {3037736},
 address = {New York, NY, USA},
 author = {Kanev, Svilen and Xi, Sam Likun and Wei, Gu-Yeon and Brooks, David},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037736},
 isbn = {978-1-4503-4465-4},
 keyword = {accelerators, datacenter tax, memory allocation},
 link = {http://doi.acm.org/10.1145/3037697.3037736},
 location = {Xi'an, China},
 numpages = {13},
 pages = {33--45},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Mallacc: Accelerating Memory Allocation},
 year = {2017}
}


@article{Wang:2017:GSD:3093315.3037744,
 abstract = {There is more than a decade-long history of using static analysis to find bugs in systems such as Linux. Most of the existing static analyses developed for these systems are simple checkers that find bugs based on pattern matching. Despite the presence of many sophisticated interprocedural analyses, few of them have been employed to improve checkers for systems code due to their complex implementations and poor scalability. In this paper, we revisit the scalability problem of interprocedural static analysis from a "Big Data" perspective. That is, we turn sophisticated code analysis into Big Data analytics and leverage novel data processing techniques to solve this traditional programming language problem. We develop Graspan, a disk-based parallel graph system that uses an edge-pair centric computation model to compute dynamic transitive closures on very large program graphs. We implement context-sensitive pointer/alias and dataflow analyses on Graspan. An evaluation of these analyses on large codebases such as Linux shows that their Graspan implementations scale to millions of lines of code and are much simpler than their original implementations. Moreover, we show that these analyses can be used to augment the existing checkers; these augmented checkers uncovered 132 new NULL pointer bugs and 1308 unnecessary NULL tests in Linux 4.4.0-rc5, PostgreSQL 8.3.9, and Apache httpd 2.2.18.},
 acmid = {3037744},
 address = {New York, NY, USA},
 author = {Wang, Kai and Hussain, Aftab and Zuo, Zhiqiang and Xu, Guoqing and Amiri Sani, Ardalan},
 doi = {10.1145/3093315.3037744},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {disk-based systems, graph processing, static analysis},
 link = {http://doi.acm.org/10.1145/3093315.3037744},
 month = {apr},
 number = {2},
 numpages = {16},
 pages = {389--404},
 publisher = {ACM},
 title = {Graspan: A Single-machine Disk-based Graph System for Interprocedural Static Analyses of Large-scale Systems Code},
 volume = {51},
 year = {2017}
}


@inproceedings{Cox:2017:EAT:3037697.3037704,
 abstract = {Processors and operating systems (OSes) support multiple memory page sizes. Superpages increase Translation Lookaside Buffer (TLB) hits, while small pages provide fine-grained memory protection. Ideally, TLBs should perform well for any distribution of page sizes. In reality, set-associative TLBs -- used frequently for their energy efficiency compared to fully-associative TLBs -- cannot (easily) support multiple page sizes concurrently. Instead, commercial systems typically implement separate set-associative TLBs for different page sizes. This means that when superpages are allocated aggressively, TLB misses may, counter intuitively, increase even if entries for small pages remain unused (and vice-versa). We invent MIX TLBs, energy-frugal set-associative structures that concurrently support all page sizes by exploiting superpage allocation patterns. MIX TLBs boost the performance (often by 10-30%) of big-memory applications on native CPUs, virtualized CPUs, and GPUs. MIX TLBs are simple and require no OS or program changes.},
 acmid = {3037704},
 address = {New York, NY, USA},
 author = {Cox, Guilherme and Bhattacharjee, Abhishek},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037704},
 isbn = {978-1-4503-4465-4},
 keyword = {coalescing, superpages, tlb, virtual memory},
 link = {http://doi.acm.org/10.1145/3037697.3037704},
 location = {Xi'an, China},
 numpages = {14},
 pages = {435--448},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Efficient Address Translation for Architectures with Multiple Page Sizes},
 year = {2017}
}


@article{Ge:2017:GGC:3093337.3037716,
 abstract = {Researchers are actively exploring techniques to enforce control-flow integrity (CFI), which restricts program execution to a predefined set of targets for each indirect control transfer to prevent code-reuse attacks. While hardware-assisted CFI enforcement may have the potential for advantages in performance and flexibility over software instrumentation, current hardware-assisted defenses are either incomplete (i.e., do not enforce all control transfers) or less efficient in comparison. We find that the recent introduction of hardware features to log complete control-flow traces, such as Intel Processor Trace (PT), provides an opportunity to explore how efficient and flexible a hardware-assisted CFI enforcement system may become. While Intel PT was designed to aid in offline debugging and failure diagnosis, we explore its effectiveness for online CFI enforcement over unmodified binaries by designing a parallelized method for enforcing various types of CFI policies. We have implemented a prototype called GRIFFIN in the Linux 4.2 kernel that enables complete CFI enforcement over a variety of software, including the Firefox browser and its jitted code. Our experiments show that GRIFFIN can enforce fine-grained CFI policies with shadow stack as recommended by researchers at a performance that is comparable to software-only instrumentation techniques. In addition, we find that alternative logging approaches yield significant performance improvements for trace processing, identifying opportunities for further hardware assistance.},
 acmid = {3037716},
 address = {New York, NY, USA},
 author = {Ge, Xinyang and Cui, Weidong and Jaeger, Trent},
 doi = {10.1145/3093337.3037716},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {control-flow integrity, intel processor trace},
 link = {http://doi.acm.org/10.1145/3093337.3037716},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {585--598},
 publisher = {ACM},
 title = {GRIFFIN: Guarding Control Flows Using Intel Processor Trace},
 volume = {45},
 year = {2017}
}


@article{Khazraee:2017:MNO:3093336.3037749,
 abstract = {Cloud services are becoming increasingly globalized and data-center workloads are expanding exponentially. GPU and FPGA-based clouds have illustrated improvements in power and performance by accelerating compute-intensive workloads. ASIC-based clouds are a promising way to optimize the Total Cost of Ownership (TCO) of a given datacenter computation (e.g. YouTube transcoding) by reducing both energy consumption and marginal computation cost. The feasibility of an ASIC Cloud for a particular application is directly gated by the ability to manage the Non-Recurring Engineering (NRE) costs of designing and fabricating the ASIC, so that it is significantly lower (e.g. 2X) than the TCO of the best available alternative. In this paper, we show that technology node selection is a major tool for managing ASIC Cloud NRE, and allows the designer to trade off an accelerator's excess energy efficiency and cost performance for lower total cost. We explore NRE and cross-technology optimization of ASIC Clouds for four different applications: Bitcoin mining, YouTube-style video transcoding, Litecoin, and Deep Learning. We address these challenges and show large reductions in the NRE, potentially enabling ASIC Clouds to address a wider variety of datacenter workloads. Our results suggest that advanced nodes like 16nm will lead to sub-optimal TCO for many workloads, and that use of older nodes like 65nm can enable a greater diversity of ASIC Clouds.},
 acmid = {3037749},
 address = {New York, NY, USA},
 author = {Khazraee, Moein and Zhang, Lu and Vega, Luis and Taylor, Michael Bedford},
 doi = {10.1145/3093336.3037749},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {accelerator, asic cloud, datacenter, nre, tco},
 link = {http://doi.acm.org/10.1145/3093336.3037749},
 month = {apr},
 number = {4},
 numpages = {16},
 pages = {511--526},
 publisher = {ACM},
 title = {Moonwalk: NRE Optimization in ASIC Clouds},
 volume = {52},
 year = {2017}
}


@article{Nalli:2017:APM:3093315.3037730,
 abstract = {Emerging non-volatile memory (NVM) technologies promise durability with read and write latencies comparable to volatile memory (DRAM). We define Persistent Memory (PM) as NVM accessed with byte addressability at low latency via normal memory instructions. Persistent-memory applications ensure the consistency of persistent data by inserting ordering points between writes to PM allowing the construction of higher-level transaction mechanisms. An epoch is a set of writes to PM between ordering points. To put systems research in PM on a firmer footing, we developed and analyzed a PM benchmark suite called WHISPER (Wisconsin-HP Labs Suite for Persistence) that comprises ten PM applications we gathered to cover all current interfaces to PM. A quantitative analysis reveals several insights: (a) only 4% of writes in PM-aware applications are to PM and the rest are to volatile memory, (b) software transactions are often implemented with 5 to 50 ordering points (c) 75% of epochs update exactly one 64B cache line, (d) 80% of epochs from the same thread depend on previous epochs from the same thread, while few epochs depend on epochs from other threads. Based on our analysis, we propose the Hands-off Persistence System (HOPS) to track updates to PM in hardware. Current hardware design requires applications to force data to PM as each epoch ends. HOPS provides high-level ISA primitives for applications to express durability and ordering constraints separately and enforces them automatically, while achieving 24.3% better performance over current approaches to persistence.},
 acmid = {3037730},
 address = {New York, NY, USA},
 author = {Nalli, Sanketh and Haria, Swapnil and Hill, Mark D. and Swift, Michael M. and Volos, Haris and Keeton, Kimberly},
 doi = {10.1145/3093315.3037730},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {benchmark, caches, non-volatile memory (nvm), persistent memory (pm), storage-class memory},
 link = {http://doi.acm.org/10.1145/3093315.3037730},
 month = {apr},
 number = {2},
 numpages = {14},
 pages = {135--148},
 publisher = {ACM},
 title = {An Analysis of Persistent Memory Use with WHISPER},
 volume = {51},
 year = {2017}
}


@article{Powers:2017:BBG:3093336.3037727,
 abstract = {Applications written to run on conventional operating systems typically depend on OS abstractions like processes, pipes, signals, sockets, and a shared file system. Porting these applications to the web currently requires extensive rewriting or hosting significant portions of code server-side because browsers present a nontraditional runtime environment that lacks OS functionality. This paper presents Browsix, a framework that bridges the considerable gap between conventional operating systems and the browser, enabling unmodified programs expecting a Unix-like environment to run directly in the browser. Browsix comprises two core parts: (1) a JavaScript-only system that makes core Unix features (including pipes, concurrent processes, signals, sockets, and a shared file system) available to web applications; and (2) extended JavaScript runtimes for C, C++, Go, and Node.js that support running programs written in these languages as processes in the browser. Browsix supports running a POSIX shell, making it straightforward to connect applications together via pipes. We illustrate Browsix's capabilities via case studies that demonstrate how it eases porting legacy applications to the browser and enables new functionality. We demonstrate a Browsix-enabled LaTeX editor that operates by executing unmodified versions of pdfLaTeX and BibTeX. This browser-only LaTeX editor can render documents in seconds, making it fast enough to be practical. We further demonstrate how Browsix lets us port a client-server application to run entirely in the browser for disconnected operation. Creating these applications required less than 50 lines of glue code and no code modifications, demonstrating how easily Browsix can be used to build sophisticated web applications from existing parts without modification.},
 acmid = {3037727},
 address = {New York, NY, USA},
 author = {Powers, Bobby and Vilk, John and Berger, Emery D.},
 doi = {10.1145/3093336.3037727},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {browser, browsix, javascript, operating system},
 link = {http://doi.acm.org/10.1145/3093336.3037727},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {253--266},
 publisher = {ACM},
 title = {Browsix: Bridging the Gap Between Unix and the Browser},
 volume = {52},
 year = {2017}
}


@article{Nguyen:2017:SPN:3093336.3037750,
 abstract = {Transactional memory (TM) has been the focus of numerous studies, and it is supported in processors such as the IBM Blue Gene/Q and Intel Haswell. Many studies have used the STAMP benchmark suite to evaluate their designs. However, the speedups obtained for the STAMP benchmarks on all TM systems we know of are quite limited; for example, with 64 threads on the IBM Blue Gene/Q, we observe a median speedup of 1.4X using the Blue Gene/Q hardware transactional memory (HTM), and a median speedup of 4.1X using a software transactional memory (STM). What limits the performance of these benchmarks on TMs? In this paper, we argue that the problem lies with the programming model and data structures used to write them. To make this point, we articulate two principles that we believe must be embodied in any scalable program and argue that STAMP programs violate both of them. By modifying the STAMP programs to satisfy both principles, we produce a new set of programs that we call the Stampede suite. Its median speedup on the Blue Gene/Q is 8.0X when using an STM. The two principles also permit us to simplify the TM design. Using this new STM with the Stampede benchmarks, we obtain a median speedup of 17.7X with 64 threads on the Blue Gene/Q and 13.2X with 32 threads on an Intel Westmere system. These results suggest that HTM and STM designs will benefit if more attention is paid to the division of labor between application programs, systems software, and hardware.},
 acmid = {3037750},
 address = {New York, NY, USA},
 author = {Nguyen, Donald and Pingali, Keshav},
 doi = {10.1145/3093336.3037750},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {programming models, scalability, stampede benchmarks, transactional memory, transactions},
 link = {http://doi.acm.org/10.1145/3093336.3037750},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {105--118},
 publisher = {ACM},
 title = {What Scalable Programs Need from Transactional Memory},
 volume = {52},
 year = {2017}
}


@article{Cherupalli:2017:DAP:3093337.3037711,
 abstract = {Many emerging applications such as IoT, wearables, implantables, and sensor networks are power- and energy-constrained. These applications rely on ultra-low-power processors that have rapidly become the most abundant type of processor manufactured today. In the ultra-low-power embedded systems used by these applications, peak power and energy requirements are the primary factors that determine critical system characteristics, such as size, weight, cost, and lifetime. While the power and energy requirements of these systems tend to be application-specific, conventional techniques for rating peak power and energy cannot accurately bound the power and energy requirements of an application running on a processor, leading to over-provisioning that increases system size and weight. In this paper, we present an automated technique that performs hardware-software co-analysis of the application and ultra-low-power processor in an embedded system to determine application-specific peak power and energy requirements. Our technique provides more accurate, tighter bounds than conventional techniques for determining peak power and energy requirements, reporting 15% lower peak power and 17% lower peak energy, on average, than a conventional approach based on profiling and guardbanding. Compared to an aggressive stressmark-based approach, our technique reports power and energy bounds that are 26% and 26% lower, respectively, on average. Also, unlike conventional approaches, our technique reports guaranteed bounds on peak power and energy independent of an application's input set. Tighter bounds on peak power and energy can be exploited to reduce system size, weight, and cost.},
 acmid = {3037711},
 address = {New York, NY, USA},
 author = {Cherupalli, Hari and Duwe, Henry and Ye, Weidong and Kumar, Rakesh and Sartori, John},
 doi = {10.1145/3093337.3037711},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {embedded computing, internet of things (iot), power, energy management},
 link = {http://doi.acm.org/10.1145/3093337.3037711},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {3--16},
 publisher = {ACM},
 title = {Determining Application-specific Peak Power and Energy Requirements for Ultra-low Power Processors},
 volume = {45},
 year = {2017}
}


@article{Seo:2017:FSP:3093336.3037737,
 abstract = {The slotted-page structure is a database page format commonly used for managing variable-length records. In this work, we develop a novel "failure-atomic slotted page structure" for persistent memory that leverages byte addressability and durability of persistent memory to minimize redundant write operations used to maintain consistency in traditional database systems. Failure-atomic slotted paging consists of two key elements: (i) in-place commit per page using hardware transactional memory and (ii) slot header logging that logs the commit mark of each page. The proposed scheme is implemented in SQLite and compared against NVWAL, the current state-of-the-art scheme. Our performance study shows that our failure-atomic slotted paging shows optimal performance for database transactions that insert a single record. For transactions that touch more than one database page, our proposed slot-header logging scheme minimizes the logging overhead by avoiding duplicating pages and logging only the metadata of the dirty pages. Overall, we find that our failure-atomic slotted-page management scheme reduces database logging overhead to 1/6 and improves query response time by up to 33% compared to NVWAL.},
 acmid = {3037737},
 address = {New York, NY, USA},
 author = {Seo, Jihye and Kim, Wook-Hee and Baek, Woongki and Nam, Beomseok and Noh, Sam H.},
 doi = {10.1145/3093336.3037737},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {database buffer caching, database recovery, non-volatile memory, slotted page structure},
 link = {http://doi.acm.org/10.1145/3093336.3037737},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {91--104},
 publisher = {ACM},
 title = {Failure-Atomic Slotted Paging for Persistent Memory},
 volume = {52},
 year = {2017}
}


@article{Rajbhandari:2017:OCM:3093315.3037745,
 abstract = {Convolutional Neural Networks (CNN) are a class of Ar- tificial Neural Networks (ANN) that are highly efficient at the pattern recognition tasks that underlie difficult AI prob- lems in a variety of domains, such as speech recognition, object recognition, and natural language processing. CNNs are, however, computationally intensive to train. This paper presents the first characterization of the per- formance optimization opportunities for training CNNs on CPUs. Our characterization includes insights based on the structure of the network itself (i.e., intrinsic arithmetic inten- sity of the convolution and its scalability under parallelism) as well as dynamic properties of its execution (i.e., sparsity of the computation). Given this characterization, we present an automatic framework called spg-CNN for optimizing CNN training on CPUs. It comprises of a computation scheduler for efficient parallel execution, and two code generators: one that opti- mizes for sparsity, and the other that optimizes for spatial reuse in convolutions. We evaluate spg-CNN using convolutions from a variety of real world benchmarks, and show that spg-CNN can train CNNs faster than state-of-the-art approaches by an order of magnitude.},
 acmid = {3037745},
 address = {New York, NY, USA},
 author = {Rajbhandari, Samyam and He, Yuxiong and Ruwase, Olatunji and Carbin, Michael and Chilimbi, Trishul},
 doi = {10.1145/3093315.3037745},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {avx, convolution kernel generation, convolution neural network, convolution with sparsity, cpu, cpu optimization, deep learning, optimizing convolution, parallel gemm, simd, sparsity},
 link = {http://doi.acm.org/10.1145/3093315.3037745},
 month = {apr},
 number = {2},
 numpages = {14},
 pages = {267--280},
 publisher = {ACM},
 title = {Optimizing CNNs on Multicores for Scalability, Performance and Goodput},
 volume = {51},
 year = {2017}
}


@article{Hu:2017:TFC:3093337.3037713,
 abstract = {With exploding traffic stuffing existing network infra-structure, today's telecommunication and cloud service providers resort to Network Function Virtualization (NFV) for greater agility and economics. Pioneer service provider such as AT&T proposes to adopt container in NFV to achieve shorter Virtualized Network Function (VNF) provisioning time and better runtime performance. However, we characterize typical NFV work-loads on the containers and find that the performance is unsatisfactory. We observe that the shared host OS net-work stack is the main bottleneck, where the traffic flow processing involves a large amount of intermediate memory buffers and results in significant last level cache pollution. Existing OS memory allocation policies fail to exploit the locality and data sharing information among buffers. In this paper, we propose NetContainer, a software framework that achieves fine-grained hardware resource management for containerized NFV platform. NetContainer employs a cache access overheads guided page coloring scheme to coordinately address the inter-flow cache access overheads and intra-flow cache access overheads. It maps the memory buffer pages that manifest low cache access overheads (across a flow or among the flows) to the same last level cache partition. NetContainer exploits a footprint theory based method to estimate the cache access overheads and a Min-Cost Max-Flow model to guide the memory buffer mappings. We implement the NetContainer in Linux kernel and extensively evaluate it with real NFV workloads. Exper-imental results show that NetContainer outperforms conventional page coloring-based memory allocator by 48% in terms of successful call rate.},
 acmid = {3037713},
 address = {New York, NY, USA},
 author = {Hu, Yang and Song, Mingcong and Li, Tao},
 doi = {10.1145/3093337.3037713},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {container, networking, nfv, page coloring, session initiation protocol},
 link = {http://doi.acm.org/10.1145/3093337.3037713},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {467--481},
 publisher = {ACM},
 title = {Towards "Full Containerization" in Containerized Network Function Virtualization},
 volume = {45},
 year = {2017}
}


@article{Liu:2017:DAD:3093315.3037735,
 abstract = {In big data and cloud computing era, reliability of distributed systems is extremely important. Unfortunately, distributed concurrency bugs, referred to as DCbugs, widely exist. They hide in the large state space of distributed cloud systems and manifest non-deterministically depending on the timing of distributed computation and communication. Effective techniques to detect DCbugs are desired. This paper presents a pilot solution, DCatch, in the world of DCbug detection. DCatch predicts DCbugs by analyzing correct execution of distributed systems. To build DCatch, we design a set of happens-before rules that model a wide variety of communication and concurrency mechanisms in real-world distributed cloud systems. We then build runtime tracing and trace analysis tools to effectively identify concurrent conflicting memory accesses in these systems. Finally, we design tools to help prune false positives and trigger DCbugs. We have evaluated DCatch on four representative open-source distributed cloud systems, Cassandra, Hadoop MapReduce, HBase, and ZooKeeper. By monitoring correct execution of seven workloads on these systems, DCatch reports 32 DCbugs, with 20 of them being truly harmful.},
 acmid = {3037735},
 address = {New York, NY, USA},
 author = {Liu, Haopeng and Li, Guangpu and Lukman, Jeffrey F. and Li, Jiaxin and Lu, Shan and Gunawi, Haryadi S. and Tian, Chen},
 doi = {10.1145/3093315.3037735},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {bug detection, cloud computing, concurrency bugs, distributed systems},
 link = {http://doi.acm.org/10.1145/3093315.3037735},
 month = {apr},
 number = {2},
 numpages = {15},
 pages = {677--691},
 publisher = {ACM},
 title = {DCatch: Automatically Detecting Distributed Concurrency Bugs in Cloud Systems},
 volume = {51},
 year = {2017}
}


@article{Misra:2017:ELT:3093337.3037722,
 abstract = {Distributed transactional storage is an important service in today's data centers. Achieving high performance without high complexity is often a challenge for these systems due to sophisticated consistency protocols and multiple layers of abstraction. In this paper we show how to combine two emerging technologies---Software-Defined Flash (SDF) and precise synchronized clocks---to improve performance and reduce complexity for transactional storage within the data center. We present a distributed transactional system (called MILANA) as a layer above a durable multi-version key-value store (called SEMEL) for read-heavy workloads within a data center. SEMEL exploits write behavior of SSDs to maintain a time-ordered sequence of versions for each key efficiently and durably. MILANA adds a variant of optimistic concurrency control above SEMEL's API to service read requests from a consistent snapshot and to enable clients to make fast local commit or abort decisions for read-only transactions. Experiments with the prototype reveal up to 43% lower transaction abort rates using IEEE Precision Time Protocol (PTP) vs. the standard Network Time Protocol (NTP). Under the Retwis benchmark, client-local validation of read-only transactions yields a 35% reduction in latency and 55% increase in transaction throughput.},
 acmid = {3037722},
 address = {New York, NY, USA},
 author = {Misra, Pulkit A. and Chase, Jeffrey S. and Gehrke, Johannes and Lebeck, Alvin R.},
 doi = {10.1145/3093337.3037722},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {clock-synchronization, distributed storage systems, non-volatile memory, strong consistency, transactions},
 link = {http://doi.acm.org/10.1145/3093337.3037722},
 month = {apr},
 number = {1},
 numpages = {16},
 pages = {779--794},
 publisher = {ACM},
 title = {Enabling Lightweight Transactions with Precision Time},
 volume = {45},
 year = {2017}
}


@article{Liu:2017:ITI:3093315.3037731,
 abstract = {The emergence of programmable network devices and the increasing data traffic of datacenters motivate the idea of in-network computation. By offloading compute operations onto intermediate networking devices (e.g., switches, network accelerators, middleboxes), one can (1) serve network requests on the fly with low latency; (2) reduce datacenter traffic and mitigate network congestion; and (3) save energy by running servers in a low-power mode. However, since (1) existing switch technology doesn't provide general computing capabilities, and (2) commodity datacenter networks are complex (e.g., hierarchical fat-tree topologies, multipath communication), enabling in-network computation inside a datacenter is challenging. In this paper, as a step towards in-network computing, we present IncBricks, an in-network caching fabric with basic computing primitives. IncBricks is a hardware-software co-designed system that supports caching in the network using a programmable network middlebox. As a key-value store accelerator, our prototype lowers request latency by over 30% and doubles throughput for 1024 byte values in a common cluster configuration. Our results demonstrate the effectiveness of in-network computing and that efficient datacenter network request processing is possible if we carefully split the computation across the different programmable computing elements in a datacenter, including programmable switches, network accelerators, and end hosts.},
 acmid = {3037731},
 address = {New York, NY, USA},
 author = {Liu, Ming and Luo, Liang and Nelson, Jacob and Ceze, Luis and Krishnamurthy, Arvind and Atreya, Kishore},
 doi = {10.1145/3093315.3037731},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {in-network caching, programmable network devices},
 link = {http://doi.acm.org/10.1145/3093315.3037731},
 month = {apr},
 number = {2},
 numpages = {15},
 pages = {795--809},
 publisher = {ACM},
 title = {IncBricks: Toward In-Network Computation with an In-Network Cache},
 volume = {51},
 year = {2017}
}


@inproceedings{Olson:2017:CGM:3037697.3037715,
 abstract = {Specialized hardware accelerators have performance and energy-efficiency advantages over general-purpose processors. To fully realize these benefits and aid programmability, accelerators may share a physical and virtual address space and full cache coherence with the host system. However, allowing accelerators -- particularly those designed by third parties -- to directly communicate with host coherence protocols poses several problems. Host coherence protocols are complex, vary between companies, and may be proprietary, increasing burden on accelerator designers. Bugs in the accelerator implementation may cause crashes and other serious consequences to the host system. We propose Crossing Guard, a coherence interface between the host coherence system and accelerators. The Crossing Guard interface provides the accelerator designer with a standardized set of coherence messages that are simple enough to aid in design of bug-free coherent caches. At the same time, they are sufficiently complex to allow customized and optimized accelerator caches with performance comparable to using the host protocol. The Crossing Guard hardware is implemented as part of the trusted host, and provides complete safety to the host coherence system, even in the presence of a pathologically buggy accelerator cache.},
 acmid = {3037715},
 address = {New York, NY, USA},
 author = {Olson, Lena E. and Hill, Mark D. and Wood, David A.},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037715},
 isbn = {978-1-4503-4465-4},
 keyword = {accelerators, cache coherence, coherence interfaces},
 link = {http://doi.acm.org/10.1145/3037697.3037715},
 location = {Xi'an, China},
 numpages = {14},
 pages = {163--176},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Crossing Guard: Mediating Host-Accelerator Coherence Interactions},
 year = {2017}
}


@article{Elyasi:2017:EIS:3093337.3037728,
 abstract = {With Solid State Disks (SSDs) offering high degrees of parallelism, SSD controllers place data and direct requests to exploit the maximum offered hardware parallelism. In the quest to maximize parallelism and utilization, sub-requests of a request that are directed to different flash chips by the scheduler can experience differential wait times since their individual queues are not coordinated and load balanced at all times. Since the macro request is considered complete only when its last sub-request completes, some of its sub-requests that complete earlier have to necessarily wait for this last sub-request. This paper opens the door to a new class of schedulers to leverage such slack between sub-requests in order to improve response times. Specifically, the paper presents the design and implementation of a slack-enabled re-ordering scheduler, called Slacker, for sub-requests issued to each flash chip. Layered under a modern SSD request scheduler, Slacker estimates the slack of each incoming sub-request to a flash chip and allows them to jump ahead of existing sub-requests with sufficient slack so as to not detrimentally impact their response times. Slacker is simple to implement and imposes only marginal additions to the hardware. Using a spectrum of 21 workloads with diverse read-write characteristics, we show that Slacker provides as much as 19.5%, 13% and 14.5% improvement in response times, with average improvements of 12%, 6.5% and 8.5%, for write-intensive, read-intensive and read-write balanced workloads, respectively.},
 acmid = {3037728},
 address = {New York, NY, USA},
 author = {Elyasi, Nima and Arjomand, Mohammad and Sivasubramaniam, Anand and Kandemir, Mahmut T. and Das, Chita R. and Jung, Myoungsoo},
 doi = {10.1145/3093337.3037728},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {intra-request slack, scheduling, ssd},
 link = {http://doi.acm.org/10.1145/3093337.3037728},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {375--388},
 publisher = {ACM},
 title = {Exploiting Intra-Request Slack to Improve SSD Performance},
 volume = {45},
 year = {2017}
}


@article{Gao:2017:TSE:3093337.3037702,
 abstract = {The high accuracy of deep neural networks (NNs) has led to the development of NN accelerators that improve performance by two orders of magnitude. However, scaling these accelerators for higher performance with increasingly larger NNs exacerbates the cost and energy overheads of their memory systems, including the on-chip SRAM buffers and the off-chip DRAM channels. This paper presents the hardware architecture and software scheduling and partitioning techniques for TETRIS, a scalable NN accelerator using 3D memory. First, we show that the high throughput and low energy characteristics of 3D memory allow us to rebalance the NN accelerator design, using more area for processing elements and less area for SRAM buffers. Second, we move portions of the NN computations close to the DRAM banks to decrease bandwidth pressure and increase performance and energy efficiency. Third, we show that despite the use of small SRAM buffers, the presence of 3D memory simplifies dataflow scheduling for NN computations. We present an analytical scheduling scheme that matches the efficiency of schedules derived through exhaustive search. Finally, we develop a hybrid partitioning scheme that parallelizes the NN computations over multiple accelerators. Overall, we show that TETRIS improves mthe performance by 4.1x and reduces the energy by 1.5x over NN accelerators with conventional, low-power DRAM memory systems.},
 acmid = {3037702},
 address = {New York, NY, USA},
 author = {Gao, Mingyu and Pu, Jing and Yang, Xuan and Horowitz, Mark and Kozyrakis, Christos},
 doi = {10.1145/3093337.3037702},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {3d memory, acceleration, dataflow scheduling, neural networks, partitioning},
 link = {http://doi.acm.org/10.1145/3093337.3037702},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {751--764},
 publisher = {ACM},
 title = {TETRIS: Scalable and Efficient Neural Network Acceleration with 3D Memory},
 volume = {45},
 year = {2017}
}


@article{Song:2017:HAF:3093337.3037753,
 abstract = {NUMA (non-uniform memory access) servers are commonly used in high-performance computing and datacenters. Within each server, a processor-interconnect (e.g., Intel QPI, AMD HyperTransport) is used to communicate between the different sockets or nodes. In this work, we explore the impact of the processor-interconnect on overall performance -- in particular, the performance un- fairness caused by processor-interconnect arbitration. It is well known that locally-fair arbitration does not guarantee globally-fair bandwidth sharing as closer nodes receive more bandwidth in a multi-hop network. However, this work demonstrates that the opposite can occur in a commodity NUMA server where remote nodes receive higher bandwidth (and perform better). We analyze this problem and iden- tify that this occurs because of external concentration used in router micro-architectures for processor-interconnects without globally-aware arbitration. While accessing remote memory can occur in any NUMA system, performance un- fairness (or performance variation) is more critical in cloud computing and virtual machines with shared resources. We demonstrate how this unfairness creates significant performance variation when a workload is executed on the Xen virtualization platform. We then provide analysis using synthetic workloads to better understand the source of unfair- ness and eliminate the impact of other shared resources, including the shared last-level cache and main memory. To provide fairness, we propose a novel, history-based arbitration that tracks the history of arbitration grants made in the previous history window. A weighted arbitration is done based on the history to provide global fairness. Through simulations, we show our proposed history-based arbitration can provide global fairness and minimize the processor- interconnect performance unfairness at low cost.},
 acmid = {3037753},
 address = {New York, NY, USA},
 author = {Song, Wonjun and Kim, Gwangsun and Jung, Hyungjoon and Chung, Jongwook and Ahn, Jung Ho and Lee, Jae W. and Kim, John},
 doi = {10.1145/3093337.3037753},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {arbitration, numa servers, processor-interconnect, router concentration},
 link = {http://doi.acm.org/10.1145/3093337.3037753},
 month = {apr},
 number = {1},
 numpages = {13},
 pages = {765--777},
 publisher = {ACM},
 title = {History-Based Arbitration for Fairness in Processor-Interconnect of NUMA Servers},
 volume = {45},
 year = {2017}
}


@proceedings{Conte:2016:2872362,
 abstract = {It is my pleasure and privilege to serve as program chair for ASPLOS 2016 -- the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems. This year's conference has set new records in terms of the number of submissions, and reinforces ASPLOS's tradition of encouraging work on innovative multidisciplinary research spanning computer architecture and hardware, programming languages and compilers, operating systems and networking, and applications. The 2016 conference saw a record, 232 submissions with a total of 986 (unique 877) paper authors from 240 institutions spread across at least 21 countries and spanning 5 continents: a clear indication that our community is growing, and that ASPLOS is the premier venue of choice for disseminating high quality interdisciplinary work. There was a wide diversity in topics, ranging from DNA computer storage to human computer interaction, with the most popular being heterogeneous architecture and accelerators, security, reliability and debugging, and memory management. 55 papers self-identified as relating to architecture, 55 to parallelism, 59 to operating systems, 40 to programming models and languages, and 20 to compiler optimizations. Some Notes on the Review Process: All reviewing and discussion, including that at the PC meeting, was double blind. As in past ASPLOS conferences, I used a 2-phase review process, with each paper receiving 3 reviews in round 1, and a minimum of an additional 2 reviews in round 2. In order to improve the quality of review assignment, in conjunction with the paper title and abstract (with sometimes a need to skim the paper directly), I used a combination of topic and interest match with reviewers, and suggestions for reviewers from both the authors and the round 1 reviewers (during the round 2 assignment). I continued to monitor reviews for papers through both rounds 1 and 2 as they came in for quality, substance, and tone, to correct any expertise mismatch, and to find experts in the multiple areas each paper might span, including experts outside of the program and external review committees, a step that is essential for a conference with the breadth that ASPLOS covers. Reviewer feedback in this process was extremely helpful. In keeping with ASPLOS'15 and other conferences, not all papers were moved to round 2. In particular, papers with no round 1 reviews advocating acceptance, and with clear consensus (based both on substantive review content and comment exchange) among the reviewers that the paper did not rise above the acceptance bar for the conference, did not move to round 2. Approximately 35.27% of the papers fell in this category. Each of these decisions involved the active participation of all the reviewers. After the rebuttal phase, each paper was assigned a discussion lead. The discussion lead's job was to carefully read all reviews, the rebuttal, and prior online comments (several papers had extensive online discussions after both rounds 1 and 2), and then initiate a discussion with the goal of reaching a conclusion on whether papers were to be accepted, rejected, or discussed at the PC meeting. The goal of the discussion lead (and my monitoring) was to ensure that every reviewer participated in the discussion after reading the other reviews and the rebuttal. During this process, if new reviewers were considered required based on the rebuttal content, they were sought. The program committee meeting was held at the Chicago O'Hare Hilton on November 7th, 2014. All but four PC members were in attendance, due to medical emergencies or health issues. PC members had access to the reviews for all papers for which they had no declared conflict. Paper authors were not revealed during the PC meeting, and since the discussion continued to be blind, PC papers were not singled out for separate discussion. PC members were asked to leave the room for papers for which they were declared as a conflict (which included any papers they were authors on) prior to revealing the paper title and number being discussed. During the PC meeting, all papers categorized as a preliminary accept (15) were discussed first. The PC also had a chance during and prior to the PC meeting to bring up papers for discussion thatwere classified as tentatively rejected (i.e., all papers were open for discussion at the PC meeting). The majority of the time during the PC meeting was spent on the papers categorized as needing discussion. The result of the extensive reviewing, online discussion, and PC meeting is now in your hands for your reading pleasure, with 53 accepted papers, 16 of which were shepherded. In addition to the decision process, for every paper where the authors chose to provide a rebuttal, the discussion lead, in collaboration with the other reviewers, provided the authors with a summary outlining the main criteria leading to the decision outcome for the paper (whether or not the rebuttal answered reviewer questions or addressed concerns or shortcomings expressed in the reviews), along with feedback for improvement. The Program: In addition to the 53 accepted papers, the conference includes two invited keynote speeches. Richard Stanley Williams, a senior fellow at HP, will talk about memristors and sensible machines. Kathryn McKinley from Microsoft Research will give a talk on how to program uncertain things. We will maintain the tradition of past ASPLOS conferences in convening a Wild and Crazy Ideas (WACI) session, organized by Dan Tsafrir, and a debate session organized by Emmett Witchel. Each of which has a group of inspiring speakers line up to provoke thoughts and discussion among the audience and the whole community. Lightning sessions, each morning, managed by Ding Yuan, will provide a quick introduction to the key ideas that will be presented in the talks that day. The authors also have one more chance in the poster session to present their work and get feedback.},
 address = {New York, NY, USA},
 isbn = {978-1-4503-4091-5},
 location = {Atlanta, Georgia, USA},
 note = {415165},
 publisher = {ACM},
 title = {ASPLOS '16: Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
 year = {2016}
}


@article{Chen:2017:PPQ:3093315.3037700,
 abstract = {Guaranteeing Quality-of-Service (QoS) of latency-sensitive applications while improving server utilization through application co-location is important yet challenging in modern datacenters. The key challenge is that when applications are co-located on a server, performance interference due to resource contention can be detrimental to the application QoS. Although prior work has proposed techniques to identify "safe" co-locations where application QoS is satisfied by predicting the performance interference on multicores, no such prediction technique on accelerators such as GPUs. In this work, we present Prophet, an approach to precisely predict the performance degradation of latency-sensitive applications on accelerators due to application co-location. We analyzed the performance interference on accelerators through a real system investigation and found that unlike on multicores where the key contentious resources are shared caches and main memory bandwidth, the key contentious resources on accelerators are instead processing elements, accelerator memory bandwidth and PCIe bandwidth. Based on this observation, we designed interference models that enable the precise prediction for processing element, accelerator memory bandwidth and PCIe bandwidth contention on real hardware. By using a novel technique to forecast solo-run execution traces of the co-located applications using interference models, Prophet can accurately predict the performance degradation of latency-sensitive applications on non-preemptive accelerators. Using Prophet, we can identify "safe" co-locations on accelerators to improve utilization without violating the QoS target. Our evaluation shows that Prophet can predict the performance degradation with an average prediction error 5.47% on real systems. Meanwhile, based on the prediction, Prophet achieves accelerator utilization improvements of 49.9% on average while maintaining the QoS target of latency-sensitive applications.},
 acmid = {3037700},
 address = {New York, NY, USA},
 author = {Chen, Quan and Yang, Hailong and Guo, Minyi and Kannan, Ram Srivatsa and Mars, Jason and Tang, Lingjia},
 doi = {10.1145/3093315.3037700},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {non-preemptive accelerators, quality-of-service prediction, warehouse-scale computers},
 link = {http://doi.acm.org/10.1145/3093315.3037700},
 month = {apr},
 number = {2},
 numpages = {16},
 pages = {17--32},
 publisher = {ACM},
 title = {Prophet: Precise QoS Prediction on Non-Preemptive Accelerators to Improve Utilization in Warehouse-Scale Computers},
 volume = {51},
 year = {2017}
}


@article{Huang:2017:PSC:3093337.3037743,
 abstract = {Software optimization is constantly a serious concern for developing high-performance systems. To accelerate the workflow execution of a specific functionality, software developers usually define and implement a fast path to speed up the critical and commonly executed functions in the workflow. However, producing a bug-free fast path is nontrivial. Our study on the Linux kernel discloses that a committed fast path can have up to 19 follow-up patches for bug fixing, and most of them are deep semantic bugs, which are difficult to be pinpointed by existing bug-finding tools. In this paper, we present such a new category of software bugs based on our fast-path bug study across various system software including virtual memory manager, file systems, network, and device drivers. We investigate their root causes and identify five error-prone aspects in a fast path: path state, trigger condition, path output, fault handling, and assistant data structure. We find that many of the deep bugs can be prevented by applying static analysis incorporating simple semantic information. We extract a set of rules based on our findings and build a toolkit PALLAS to check fast-path bugs. The evaluation results show that PALLAS can effectively reveal fast-path bugs in a variety of systems including Linux kernel, mobile operating system, software-defined networking system, and web browser.},
 acmid = {3037743},
 address = {New York, NY, USA},
 author = {Huang, Jian and Allen-Bond, Michael and Zhang, Xuechen},
 doi = {10.1145/3093337.3037743},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {fast path, semantic bugs, software optimization, static analysis},
 link = {http://doi.acm.org/10.1145/3093337.3037743},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {709--722},
 publisher = {ACM},
 title = {Pallas: Semantic-Aware Checking for Finding Deep Bugs in Fast Path},
 volume = {45},
 year = {2017}
}


@article{Zhou:2017:BDA:3093337.3037699,
 abstract = {As China's largest cloud service provider, Alibaba Cloud has been one of the fastest growing cloud computing platforms in the world. In this talk, I-ll present an overview of Big Data and AI computing platform at Alibaba Cloud, which consists of a wide range of products and services to enable fast and efficient big data development and intelligent analysis. The underlying computing infrastructure supports a variety of computation scenarios, including batch, interactive, stream, and graph computation, as well as large-scale machine learning on heterogeneous cloud-scale data centers. Several big data products, such as rule-based engine, recommendation system, BI tools, etc., are provided to address different business needs. The platform not only supports Alibaba's internal businesses but also provides solid services to enterprise customers. In addition, I'll describe key techniques and system internals, and outline outstanding research and engineering challenges.},
 acmid = {3037699},
 address = {New York, NY, USA},
 author = {Zhou, Jingren},
 doi = {10.1145/3093337.3037699},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {big data, data intelligence},
 link = {http://doi.acm.org/10.1145/3093337.3037699},
 month = {apr},
 number = {1},
 numpages = {1},
 pages = {1--1},
 publisher = {ACM},
 title = {Big Data Analytics and Intelligence at Alibaba Cloud},
 volume = {45},
 year = {2017}
}


@article{Li:2017:LCC:3093336.3037709,
 abstract = {Cache is designed to exploit locality; however, the role of on-chip L1 data caches on modern GPUs is often awkward. The locality among global memory requests from different SMs (Streaming Multiprocessors) is predominantly harvested by the commonly-shared L2 with long access latency; while the in-core locality, which is crucial for performance delivery, is handled explicitly by user-controlled scratchpad memory. In this work, we disclose another type of data locality that has been long ignored but with performance boosting potential --- the inter-CTA locality. Exploiting such locality is rather challenging due to unclear hardware feasibility, unknown and inaccessible underlying CTA scheduler, and small in-core cache capacity. To address these issues, we first conduct a thorough empirical exploration on various modern GPUs and demonstrate that inter-CTA locality can be harvested, both spatially and temporally, on L1 or L1/Tex unified cache. Through further quantification process, we prove the significance and commonality of such locality among GPU applications, and discuss whether such reuse is exploitable. By leveraging these insights, we propose the concept of CTA-Clustering and its associated software-based techniques to reshape the default CTA scheduling in order to group the CTAs with potential reuse together on the same SM. Our techniques require no hardware modification and can be directly deployed on existing GPUs. In addition, we incorporate these techniques into an integrated framework for automatic inter-CTA locality optimization. We evaluate our techniques using a wide range of popular GPU applications on all modern generations of NVIDIA GPU architectures. The results show that our proposed techniques significantly improve cache performance through reducing L2 cache transactions by 55%, 65%, 29%, 28% on average for Fermi, Kepler, Maxwell and Pascal, respectively, leading to an average of 1.46x, 1.48x, 1.45x, 1.41x (up to 3.8x, 3.6x, 3.1x, 3.3x) performance speedups for applications with algorithm-related inter-CTA reuse.},
 acmid = {3037709},
 address = {New York, NY, USA},
 author = {Li, Ang and Song, Shuaiwen Leon and Liu, Weifeng and Liu, Xu and Kumar, Akash and Corporaal, Henk},
 doi = {10.1145/3093336.3037709},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {cache locality, cta, gpu, performance optimization, runtime tool},
 link = {http://doi.acm.org/10.1145/3093336.3037709},
 month = {apr},
 number = {4},
 numpages = {15},
 pages = {297--311},
 publisher = {ACM},
 title = {Locality-Aware CTA Clustering for Modern GPUs},
 volume = {52},
 year = {2017}
}


@article{Ajay:2017:IEA:3093315.3037752,
 abstract = {As the next-generation manufacturing driven force, 3D printing technology is having a transformative effect on various industrial domains and has been widely applied in a broad spectrum of applications. It also progresses towards other versatile fields with portable battery-powered 3D printers working on a limited energy budget. While reducing manufacturing energy is an essential challenge in industrial sustainability and national economics, this growing trend motivates us to explore the energy consumption of the 3D printer for the purpose of energy efficiency. To this end, we perform an in-depth analysis of energy consumption in commercial, off-the-shelf 3D printers from an instruction-level perspective. We build an instruction-level energy model and an energy profiler to analyze the energy cost during the fabrication process. From the insights obtained by the energy profiler, we propose and implement a cross-layer energy optimization solution, called 3DGates, which spans the instruction-set, the compiler and the firmware. We evaluate 3DGates over 338 benchmarks on a 3D printer and achieve an overall energy reduction of 25%.},
 acmid = {3037752},
 address = {New York, NY, USA},
 author = {Ajay, Jerry and Song, Chen and Rathore, Aditya Singh and Zhou, Chi and Xu, Wenyao},
 doi = {10.1145/3093315.3037752},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {3d printers, energy characterization and optimization, g-code instruction profiling},
 link = {http://doi.acm.org/10.1145/3093315.3037752},
 month = {apr},
 number = {2},
 numpages = {15},
 pages = {419--433},
 publisher = {ACM},
 title = {3DGates: An Instruction-Level Energy Analysis and Optimization of 3D Printers},
 volume = {51},
 year = {2017}
}


@article{McMahan:2017:ASF:3093315.3037733,
 abstract = {Building a trustworthy life-critical embedded system requires deep reasoning about the potential effects that sequences of machine instructions can have on full system operation. Rather than trying to analyze complete binaries and the countless ways their instructions can interact with one another --- memory, side effects, control registers, implicit state, etc. --- we explore a new approach. We propose an architecture controlled by a thin computational layer designed to tightly correspond with the lambda calculus, drawing on principles of functional programming to bring the assembly much closer to myriad reasoning frameworks, such as the Coq proof assistant. This approach allows assembly-level verified versions of critical code to operate safely in tandem with arbitrary code, including imperative and unverified system components, without the need for large supporting trusted computing bases. We demonstrate that this computational layer can be built in such a way as to simultaneously provide full programmability and compact, precise, and complete semantics, while still using hardware resources comparable to normal embedded systems. To demonstrate the practicality of this approach, our FPGA-implemented prototype runs an embedded medical application which monitors and treats life-threatening arrhythmias. Though the system integrates untrusted and imperative components, our architecture allows for the formal verification of multiple properties of the end-to-end system, including a proof of correctness of the assembly-level implementation of the core algorithm, the integrity of trusted data via a non-interference proof, and a guarantee that our prototype meets critical timing requirements.},
 acmid = {3037733},
 address = {New York, NY, USA},
 author = {McMahan, Joseph and Christensen, Michael and Nichols, Lawton and Roesch, Jared and Guo, Sung-Yee and Hardekopf, Ben and Sherwood, Timothy},
 doi = {10.1145/3093315.3037733},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {assembly analysis, binary verification, formal methods, functional programming, heterogeneous architecture, isa semantics, non-interference, static analysis},
 link = {http://doi.acm.org/10.1145/3093315.3037733},
 month = {apr},
 number = {2},
 numpages = {15},
 pages = {177--191},
 publisher = {ACM},
 title = {An Architecture Supporting Formal and Compositional Binary Analysis},
 volume = {51},
 year = {2017}
}


@article{Li:2017:SSL:3093336.3037740,
 abstract = {Latent Dirichlet Allocation (LDA) is a popular tool for analyzing discrete count data such as text and images. Applications require LDA to handle both large datasets and a large number of topics. Though distributed CPU systems have been used, GPU-based systems have emerged as a promising alternative because of the high computational power and memory bandwidth of GPUs. However, existing GPU-based LDA systems cannot support a large number of topics because they use algorithms on dense data structures whose time and space complexity is linear to the number of topics. In this paper, we propose SaberLDA, a GPU-based LDA system that implements a sparsity-aware algorithm to achieve sublinear time complexity and scales well to learn a large number of topics. To address the challenges introduced by sparsity, we propose a novel data layout, a new warp-based sampling kernel, and an efficient sparse count matrix updating algorithm that improves locality, makes efficient utilization of GPU warps, and reduces memory consumption. Experiments show that SaberLDA can learn from billions-token-scale data with up to 10,000 topics, which is almost two orders of magnitude larger than that of the previous GPU-based systems. With a single GPU card, SaberLDA is able to learn 10,000 topics from a dataset of billions of tokens in a few hours, which is only achievable with clusters with tens of machines before.},
 acmid = {3037740},
 address = {New York, NY, USA},
 author = {Li, Kaiwei and Chen, Jianfei and Chen, Wenguang and Zhu, Jun},
 doi = {10.1145/3093336.3037740},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {gpu, lda, palellel computing, topic model},
 link = {http://doi.acm.org/10.1145/3093336.3037740},
 month = {apr},
 number = {4},
 numpages = {13},
 pages = {497--509},
 publisher = {ACM},
 title = {SaberLDA: Sparsity-Aware Learning of Topic Models on GPUs},
 volume = {52},
 year = {2017}
}


@article{Kotra:2017:HCM:3093315.3037724,
 abstract = {DRAM cells need periodic refresh to maintain data integrity. With high capacity DRAMs, DRAM refresh poses a significant performance bottleneck as the number of rows to be refreshed (and hence the refresh cycle time, tRFC) with each refresh command increases. Modern day DRAMs perform refresh at a rank-level, while LPDDRs used in mobile environments support refresh at a per-bank level. Rank-level refresh degrades the performance significantly since none of the banks in a rank can serve the on-demand requests. Per-bank refresh alleviates some of the performance bottlenecks as the other banks in a rank are available for on-demand requests. Typical DRAM retention time is in the order several of milliseconds, viz, 64msec for environments operating in temperatures below 85 deg C and 32msec for environments operating above 85 deg C. With systems moving towards increased consolidation (ex: virtualized environments), DRAM refresh becomes a significant bottleneck as it reduces the available overall DRAM bandwidth per task. In this work, we propose a hardware-software co-design to mitigate DRAM refresh overheads by exposing the hardware address mapping and DRAM refresh schedule to the Operating System. We propose a novel DRAM refresh-aware process scheduling algorithm in OS which schedules applications on cores such that none of the on-demand requests from the application are stalled by refreshes. Extensive evaluation of our proposed co-design on multi-programmed SPEC CPU2006 workloads show significant performance improvement compared to the previously proposed hardware only approaches.},
 acmid = {3037724},
 address = {New York, NY, USA},
 author = {Kotra, Jagadish B. and Shahidi, Narges and Chishti, Zeshan A. and Kandemir, Mahmut T.},
 doi = {10.1145/3093315.3037724},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {dram refresh, hardware-software co-design, operating systems, task scheduling},
 link = {http://doi.acm.org/10.1145/3093315.3037724},
 month = {apr},
 number = {2},
 numpages = {14},
 pages = {723--736},
 publisher = {ACM},
 title = {Hardware-Software Co-design to Mitigate DRAM Refresh Overheads: A Case for Refresh-Aware Process Scheduling},
 volume = {51},
 year = {2017}
}


@article{Sundararajah:2017:LTN:3093337.3037720,
 abstract = {There has been a significant amount of effort invested in designing scheduling transformations such as loop tiling and loop fusion that rearrange the execution of dynamic instances of loop nests to place operations that access the same data close together temporally. In recent years, there has been interest in designing similar transformations that operate on recursive programs, but until now these transformations have only considered simple scenarios: multiple recursions to be fused, or a recursion nested inside a simple loop. This paper develops the first set of scheduling transformations for nested recursions: recursive methods that call other recursive methods. These are the recursive analog to nested loops. We present a transformation called recursion twisting that automatically improves locality at all levels of the memory hierarchy, and show that this transformation can yield substantial performance improvements across several benchmarks that exhibit nested recursion.},
 acmid = {3037720},
 address = {New York, NY, USA},
 author = {Sundararajah, Kirshanthan and Sakka, Laith and Kulkarni, Milind},
 doi = {10.1145/3093337.3037720},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {locality optimization, nested recursion},
 link = {http://doi.acm.org/10.1145/3093337.3037720},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {281--295},
 publisher = {ACM},
 title = {Locality Transformations for Nested Recursive Iteration Spaces},
 volume = {45},
 year = {2017}
}


@article{Churchill:2017:SLS:3093337.3037754,
 abstract = {Software fault isolation (SFI) is an important technique for the construction of secure operating systems, web browsers, and other extensible software. We demonstrate that superoptimization can dramatically improve the performance of Google Native Client, a SFI system that ships inside the Google Chrome Browser. Key to our results are new techniques for superoptimization of loops: we propose a new architecture for superoptimization tools that incorporates both a fully sound verification technique to ensure correctness and a bounded verification technique to guide the search to optimized code. In our evaluation we optimize 13 libc string functions, formally verify the correctness of the optimizations and report a median and average speedup of 25% over the libraries shipped by Google.},
 acmid = {3037754},
 address = {New York, NY, USA},
 author = {Churchill, Berkeley and Sharma, Rahul and Bastien, JF and Aiken, Alex},
 doi = {10.1145/3093337.3037754},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {assembly, bounded verification, data-driven verification, equivalence checking, native client, superoptimization, verification, x86-64},
 link = {http://doi.acm.org/10.1145/3093337.3037754},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {313--326},
 publisher = {ACM},
 title = {Sound Loop Superoptimization for Google Native Client},
 volume = {45},
 year = {2017}
}


@article{Lesokhin:2017:PFS:3093336.3037710,
 abstract = {Direct network I/O allows network controllers (NICs) to expose multiple instances of themselves, to be used by untrusted software without a trusted intermediary. Direct I/O thus frees researchers from legacy software, fueling studies that innovate in multitenant setups. Such studies, however, overwhelmingly ignore one serious problem: direct memory accesses (DMAs) of NICs disallow page faults, forcing systems to either pin entire address spaces to physical memory and thereby hinder memory utilization, or resort to APIs that pin/unpin memory buffers before/after they are DMAed, which complicates the programming model and hampers performance. We solve this problem by designing and implementing page fault support for InfiniBand and Ethernet NICs. A main challenge we tackle---unique to NICs---is handling receive DMAs that trigger page faults, leaving the NIC without memory to store the incoming data. We demonstrate that our solution provides all the benefits associated with "regular" virtual memory, notably (1) a simpler programming model that rids users from the need to pin, and (2) the ability to employ all the canonical memory optimizations, such as memory overcommitment and demand-paging based on actual use. We show that, as a result, benchmark performance improves by up to 1.9x.},
 acmid = {3037710},
 address = {New York, NY, USA},
 author = {Lesokhin, Ilya and Eran, Haggai and Raindel, Shachar and Shapiro, Guy and Grimberg, Sagi and Liss, Liran and Ben-Yehuda, Muli and Amit, Nadav and Tsafrir, Dan},
 doi = {10.1145/3093336.3037710},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {i/o page faults, iommu, memory pinning, network page faults, nic, odp, on-demand paging, paging, virtual memory},
 link = {http://doi.acm.org/10.1145/3093336.3037710},
 month = {apr},
 number = {4},
 numpages = {18},
 pages = {449--466},
 publisher = {ACM},
 title = {Page Fault Support for Network Controllers},
 volume = {52},
 year = {2017}
}


@article{Calciu:2017:BCD:3093336.3037721,
 abstract = {High-performance servers are Non-Uniform Memory Access (NUMA) machines. To fully leverage these machines, programmers need efficient concurrent data structures that are aware of the NUMA performance artifacts. We propose Node Replication (NR), a black-box approach to obtaining such data structures. NR takes an arbitrary sequential data structure and automatically transforms it into a NUMA-aware concurrent data structure satisfying linearizability. Using NR requires no expertise in concurrent data structure design, and the result is free of concurrency bugs. NR draws ideas from two disciplines: shared-memory algorithms and distributed systems. Briefly, NR implements a NUMA-aware shared log, and then uses the log to replicate data structures consistently across NUMA nodes. NR is best suited for contended data structures, where it can outperform lock-free algorithms by 3.1x, and lock-based solutions by 30x. To show the benefits of NR to a real application, we apply NR to the data structures of Redis, an in-memory storage system. The result outperforms other methods by up to 14x. The cost of NR is additional memory for its log and replicas.},
 acmid = {3037721},
 address = {New York, NY, USA},
 author = {Calciu, Irina and Sen, Siddhartha and Balakrishnan, Mahesh and Aguilera, Marcos K.},
 doi = {10.1145/3093336.3037721},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {black-box techniques, concurrent data structures, log, numa architecture, replication},
 link = {http://doi.acm.org/10.1145/3093336.3037721},
 month = {apr},
 number = {4},
 numpages = {15},
 pages = {207--221},
 publisher = {ACM},
 title = {Black-box Concurrent Data Structures for NUMA Architectures},
 volume = {52},
 year = {2017}
}


@article{Chisnall:2017:CJS:3093337.3037725,
 abstract = {Java provides security and robustness by building a high-level security model atop the foundation of memory protection. Unfortunately, any native code linked into a Java program -- including the million lines used to implement the standard library -- is able to bypass both the memory protection and the higher-level policies. We present a hardware-assisted implementation of the Java native code interface, which extends the guarantees required for Java's security model to native code. Our design supports safe direct access to buffers owned by the JVM, including hardware-enforced read-only access where appropriate. We also present Java language syntax to declaratively describe isolated compartments for native code. We show that it is possible to preserve the memory safety and isolation requirements of the Java security model in C code, allowing native code to run in the same process as Java code with the same impact on security as running equivalent Java code. Our approach has a negligible impact on performance, compared with the existing unsafe native code interface. We demonstrate a prototype implementation running on the CHERI microprocessor synthesized in FPGA.},
 acmid = {3037725},
 address = {New York, NY, USA},
 author = {Chisnall, David and Davis, Brooks and Gudka, Khilan and Brazdil, David and Joannou, Alexandre and Woodruff, Jonathan and Markettos, A. Theodore and Maste, J. Edward and Norton, Robert and Son, Stacey and Roe, Michael and Moore, Simon W. and Neumann, Peter G. and Laurie, Ben and Watson, Robert N.M.},
 doi = {10.1145/3093337.3037725},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {architecture, capability systems, cheri, compartmentalization, compilers, hardware security, java, jni, language security, memory protection, sandboxing},
 link = {http://doi.acm.org/10.1145/3093337.3037725},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {569--583},
 publisher = {ACM},
 title = {CHERI JNI: Sinking the Java Security Model into the C},
 volume = {45},
 year = {2017}
}


@article{Jevdjic:2017:ASC:3093337.3037718,
 abstract = {The popularization of video capture devices has created strong storage demand for encoded videos. Approximate storage can ease this demand by enabling denser storage at the expense of occasional errors. Unfortunately, even minor storage errors, such as bit flips, can result in major visual damage in encoded videos. Similarly, video encryption, widely employed for privacy and digital rights management, may create long dependencies between bits that show little or no tolerance to storage errors. In this paper we propose VideoApp, a novel and efficient methodology to compute bit-level reliability requirements for encoded videos by tracking visual and metadata dependencies within encoded bitstreams. We further show how VideoApp can be used to trade video quality for storage density in an optimal way. We integrate our methodology into a popular H.264 encoder to partition an encoded video stream into multiple streams that can receive different levels of error correction according to their reliability needs. When applied to a dense and highly error-prone multi-level cell storage substrate, our variable error correction mechanism reduces the error correction overhead by half under the most error-intolerant encoder settings, achieving quality/density points that neither compression nor approximation can achieve alone. Finally, we define the basic invariants needed to support encrypted approximate video storage. We present an analysis of block cipher modes of operation, showing that some are fully compatible with approximation, enabling approximate and secure video storage systems.},
 acmid = {3037718},
 address = {New York, NY, USA},
 author = {Jevdjic, Djordje and Strauss, Karin and Ceze, Luis and Malvar, Henrique S.},
 doi = {10.1145/3093337.3037718},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {approximate storage, encryption, multi-level cells, video encoding},
 link = {http://doi.acm.org/10.1145/3093337.3037718},
 month = {apr},
 number = {1},
 numpages = {13},
 pages = {361--373},
 publisher = {ACM},
 title = {Approximate Storage of Compressed and Encrypted Videos},
 volume = {45},
 year = {2017}
}


@article{Kim:2017:KPC:3093315.3037701,
 abstract = {Data prefetching and cache replacement algorithms have been intensively studied in the design of high performance microprocessors. Typically, the data prefetcher operates in the private caches and does not interact with the replacement policy in the shared Last-Level Cache (LLC). Similarly, most replacement policies do not consider demand and prefetch requests as different types of requests. In particular, program counter (PC)-based replacement policies cannot learn from prefetch requests since the data prefetcher does not generate a PC value. PC-based policies can also be negatively affected by compiler optimizations. In this paper, we propose a holistic cache management technique called Kill-the-PC (KPC) that overcomes the weaknesses of traditional prefetching and replacement policy algorithms. KPC cache management has three novel contributions. First, a prefetcher which approximates the future use distance of prefetch requests based on its prediction confidence. Second, a simple replacement policy provides similar or better performance than current state-of-the-art PC-based prediction using global hysteresis. Third, KPC integrates prefetching and replacement policy into a whole system which is greater than the sum of its parts. Information from the prefetcher is used to improve the performance of the replacement policy and vice-versa. Finally, KPC removes the need to propagate the PC through entire on-chip cache hierarchy while providing a holistic cache management approach with better performance than state-of-the-art PC-, and non-PC-based schemes. Our evaluation shows that KPC provides 8% better performance than the best combination of existing prefetcher and replacement policy for multi-core workloads.},
 acmid = {3037701},
 address = {New York, NY, USA},
 author = {Kim, Jinchun and Teran, Elvira and Gratz, Paul V. and Jim{\'e}nez, Daniel A. and Pugsley, Seth H. and Wilkerson, Chris},
 doi = {10.1145/3093315.3037701},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {cache replacemet policy, data prefetching, memory hierarchy},
 link = {http://doi.acm.org/10.1145/3093315.3037701},
 month = {apr},
 number = {2},
 numpages = {13},
 pages = {737--749},
 publisher = {ACM},
 title = {Kill the Program Counter: Reconstructing Program Behavior in the Processor Cache Hierarchy},
 volume = {51},
 year = {2017}
}


@inproceedings{Wu:2017:FEF:3037697.3037742,
 abstract = {GPUs are widely adopted in HPC and cloud computing platforms to accelerate general-purpose workloads. However, modern GPUs do not support flexible preemption, leading to performance and priority inversion problems in multi-tasking environments. In this paper, we propose and develop FLEP, the first software system that enables flexible kernel preemption and kernel scheduling on commodity GPUs. The FLEP compilation engine transforms the GPU program into preemptable forms, which can be interrupted during execution and yield all or part of the streaming multi-processors (SMs) in the GPU. The FLEP runtime engine intercepts all kernel invocations and determines which kernels and how those kernels should be preempted and scheduled. Experimental results on two-kernel co-runs demonstrate up to 24.2X speedup for high-priority kernels and up to 27X improvement on normalized average turnaround time for kernels with the same priority. FLEP reduces the preemption latency by up to 41% compared to yielding the whole GPU when the waiting kernels only need several SMs. With all the benefits, FLEP only introduces 2.5% runtime overhead, which is substantially lower than the kernel slicing approach.},
 acmid = {3037742},
 address = {New York, NY, USA},
 author = {Wu, Bo and Liu, Xu and Zhou, Xiaobo and Jiang, Changjun},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037742},
 isbn = {978-1-4503-4465-4},
 keyword = {gpgpu, kernel scheduling, multi-tasking, preemption},
 link = {http://doi.acm.org/10.1145/3037697.3037742},
 location = {Xi'an, China},
 numpages = {14},
 pages = {483--496},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {FLEP: Enabling Flexible and Efficient Preemption on GPUs},
 year = {2017}
}


@article{Ferraiuolo:2017:VPH:3093315.3037739,
 abstract = {Hardware-based mechanisms for software isolation are becoming increasingly popular, but implementing these mechanisms correctly has proved difficult, undermining the root of security. This work introduces an effective way to formally verify important properties of such hardware security mechanisms. In our approach, hardware is developed using a lightweight security-typed hardware description language (HDL) that performs static information flow analysis. We show the practicality of our approach by implementing and verifying a simplified but realistic multi-core prototype of the ARM TrustZone architecture. To make the security-typed HDL expressive enough to verify a realistic processor, we develop new type system features. Our experiments suggest that information flow analysis is efficient, and programmer effort is modest. We also show that information flow constraints are an effective way to detect hardware vulnerabilities, including several found in commercial processors.},
 acmid = {3037739},
 address = {New York, NY, USA},
 author = {Ferraiuolo, Andrew and Xu, Rui and Zhang, Danfeng and Myers, Andrew C. and Suh, G. Edward},
 doi = {10.1145/3093315.3037739},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {hardware security, information flow, trustzone},
 link = {http://doi.acm.org/10.1145/3093315.3037739},
 month = {apr},
 number = {2},
 numpages = {14},
 pages = {555--568},
 publisher = {ACM},
 title = {Verification of a Practical Hardware Security Architecture Through Static Information Flow Analysis},
 volume = {51},
 year = {2017}
}


@article{Vora:2017:KFA:3093337.3037748,
 abstract = {Continuous processing of a streaming graph maintains an approximate result of the iterative computation on a recent version of the graph. Upon a user query, the accurate result on the current graph can be quickly computed by feeding the approximate results to the iterative computation --- a form of incremental computation that corrects the (small amount of) error in the approximate result. Despite the effectiveness of this approach in processing growing graphs, it is generally not applicable when edge deletions are present --- existing approximations can lead to either incorrect results (e.g., monotonic computations terminate at an incorrect minima/maxima) or poor performance (e.g., with approximations, convergence takes longer than performing the computation from scratch). This paper presents KickStarter, a runtime technique that can trim the approximate values for a subset of vertices impacted by the deleted edges. The trimmed approximation is both safe and profitable, enabling the computation to produce correct results and converge quickly. KickStarter works for a class of monotonic graph algorithms and can be readily incorporated in any existing streaming graph system. Our experiments with four streaming algorithms on five large graphs demonstrate that trimming not only produces correct results but also accelerates these algorithms by 8.5--23.7x.},
 acmid = {3037748},
 address = {New York, NY, USA},
 author = {Vora, Keval and Gupta, Rajiv and Xu, Guoqing},
 doi = {10.1145/3093337.3037748},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {graph processing, streaming graphs, value dependence},
 link = {http://doi.acm.org/10.1145/3093337.3037748},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {237--251},
 publisher = {ACM},
 title = {KickStarter: Fast and Accurate Computations on Streaming Graphs via Trimmed Approximations},
 volume = {45},
 year = {2017}
}


@article{Zhang:2017:PPD:3093337.3037708,
 abstract = {This paper presents ProRace, a dynamic data race detector practical for production runs. It is lightweight, but still offers high race detection capability. To track memory accesses, ProRace leverages instruction sampling using the performance monitoring unit (PMU) in commodity processors. Our PMU driver enables ProRace to sample more memory accesses at a lower cost compared to the state-of-the-art Linux driver. Moreover, ProRace uses PMU-provided execution contexts including register states and program path, and reconstructs unsampled memory accesses offline. This technique allows \ProRace to overcome inherent limitations of sampling and improve the detection coverage by performing data race detection on the trace with not only sampled but also reconstructed memory accesses. Experiments using racy production software including apache and mysql shows that, with a reasonable offline cost, ProRace incurs only 2.6% overhead at runtime with 27.5% detection probability with a sampling period of 10,000.},
 acmid = {3037708},
 address = {New York, NY, USA},
 author = {Zhang, Tong and Jung, Changhee and Lee, Dongyoon},
 doi = {10.1145/3093337.3037708},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {data race detection, pebs, production, prorace, pt},
 link = {http://doi.acm.org/10.1145/3093337.3037708},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {149--162},
 publisher = {ACM},
 title = {ProRace: Practical Data Race Detection for Production Use},
 volume = {45},
 year = {2017}
}


@proceedings{Chen:2017:3037697,
 abstract = {Welcome! It has been my pleasure and privilege to serve as Program Chair for ASPLOS 2017. We received a record 320 submissions, demonstrating the continued popularity of ASPLOS's focus on multidisciplinary research spanning computer architecture, programming languages, compilers, operating systems, networking, and applications. Reflecting recent trends in systems research, popular topics included memory systems (54 submissions), programming models and languages (50), multicore (47) and heterogeneous (43) architectures, power management (41), security (33), cloud (31), virtualization (28), and GPUs (25). Review Process: All reviewing and discussion, including at the PC meeting, was double blind. As in past ASPLOS conferences, I used a 2-phase review process. In the first phase, each paper received 3 reviews, after which the reviewers discussed the papers online. Papers with at least one review that clearly advocated acceptance or two reviews that were mildly supportive, 162 of the 320 submissions, received at least two additional second round reviews. I monitored reviews to track quality and correct any expertise mismatch. After the second round of reviews were in, all authors were given the opportunity to provide rebuttal feedback. After the rebuttal phase, I assigned each paper a discussion lead to carefully read all the reviews, the rebuttal, and the online comments, and initiate a discussion to decide whether the paper should be accepted, rejected, or discussed at the PC meeting. For a few papers, I solicited post-rebuttal reviews to provide additional insights. The program committee met at the J.J. Pickle Research Center in Austin, Texas on November 7th, 2016. PC members had access to the reviews for all papers for which they had no declared conflict. Paper authors were not revealed during the PC meeting. PC papers were not explicitly identified. Before the title or paper number of any paper being discussed was revealed, conflicted PC members were asked to leave the room. We ultimately accepted a record 53 papers for publication and presentation at this year's ASPLOS, a 16.6% acceptance rate.},
 address = {New York, NY, USA},
 isbn = {978-1-4503-4465-4},
 location = {Xi'an, China},
 note = {415175},
 publisher = {ACM},
 title = {ASPLOS '17: Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 year = {2017}
}


@article{Bianchini:2017:IDE:3093315.3046426,
 abstract = {Internet companies can improve datacenter efficiency and reduce costs, by minimizing resource waste while avoiding (or limiting) performance degradation. In this talk, I will first overview a few of the efficiency-related efforts we are undertaking at Microsoft, including leveraging workload history to improve resource management. I will then discuss some lessons from deploying these efforts in production and how they relate to academic research.},
 acmid = {3046426},
 address = {New York, NY, USA},
 author = {Bianchini, Ricardo},
 doi = {10.1145/3093315.3046426},
 issn = {0163-5980},
 issue_date = {June 2017},
 journal = {SIGOPS Oper. Syst. Rev.},
 keyword = {cloud workloads, internet services, resource management},
 link = {http://doi.acm.org/10.1145/3093315.3046426},
 month = {apr},
 number = {2},
 numpages = {1},
 pages = {327--327},
 publisher = {ACM},
 title = {Improving Datacenter Efficiency},
 volume = {51},
 year = {2017}
}


@inproceedings{Ren:2017:SHD:3037697.3037746,
 abstract = {With the recent advance of wearable devices and Internet of Things (IoTs), it becomes attractive to implement the Deep Convolutional Neural Networks (DCNNs) in embedded and portable systems. Currently, executing the software-based DCNNs requires high-performance servers, restricting the widespread deployment on embedded and mobile IoT devices. To overcome this obstacle, considerable research efforts have been made to develop highly-parallel and specialized DCNN accelerators using GPGPUs, FPGAs or ASICs. Stochastic Computing (SC), which uses a bit-stream to represent a number within [-1, 1] by counting the number of ones in the bit-stream, has high potential for implementing DCNNs with high scalability and ultra-low hardware footprint. Since multiplications and additions can be calculated using AND gates and multiplexers in SC, significant reductions in power (energy) and hardware footprint can be achieved compared to the conventional binary arithmetic implementations. The tremendous savings in power (energy) and hardware resources allow immense design space for enhancing scalability and robustness for hardware DCNNs. This paper presents SC-DCNN, the first comprehensive design and optimization framework of SC-based DCNNs, using a bottom-up approach. We first present the designs of function blocks that perform the basic operations in DCNN, including inner product, pooling, and activation function. Then we propose four designs of feature extraction blocks, which are in charge of extracting features from input feature maps, by connecting different basic function blocks with joint optimization. Moreover, the efficient weight storage methods are proposed to reduce the area and power (energy) consumption. Putting all together, with feature extraction blocks carefully selected, SC-DCNN is holistically optimized to minimize area and power (energy) consumption while maintaining high network accuracy. Experimental results demonstrate that the LeNet5 implemented in SC-DCNN consumes only 17 mm2 area and 1.53 W power, achieves throughput of 781250 images/s, area efficiency of 45946 images/s/mm2, and energy efficiency of 510734 images/J.},
 acmid = {3037746},
 address = {New York, NY, USA},
 author = {Ren, Ao and Li, Zhe and Ding, Caiwen and Qiu, Qinru and Wang, Yanzhi and Li, Ji and Qian, Xuehai and Yuan, Bo},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037746},
 isbn = {978-1-4503-4465-4},
 keyword = {neural network},
 link = {http://doi.acm.org/10.1145/3037697.3037746},
 location = {Xi'an, China},
 numpages = {14},
 pages = {405--418},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {SC-DCNN: Highly-Scalable Deep Convolutional Neural Network Using Stochastic Computing},
 year = {2017}
}


@inproceedings{Wen:2017:REV:3037697.3037729,
 abstract = {Complex code bases with several layers of abstractions have abundant inefficiencies that affect the execution time. Value redundancy is a kind of inefficiency where the same values are repeatedly computed, stored, or retrieved over the course of execution. Not all redundancies can be easily detected or eliminated with compiler optimization passes due to the inherent limitations of the static analysis. Microscopic observation of whole executions at instruction- and operand-level granularity breaks down abstractions and helps recognize redundancies that masquerade in complex programs. We have developed REDSPY---a fine-grained profiler to pinpoint and quantify redundant operations in program executions. Value redundancy may happen over time at same locations or in adjacent locations, and thus it has temporal and spatial locality. REDSPY identifies both temporal and spatial value locality. Furthermore, REDSPY is capable of identifying values that are approximately the same, enabling optimization opportunities in HPC codes that often use floating point computations. REDSPY provides intuitive optimization guidance by apportioning redundancies to their provenance---source lines and execution calling contexts. REDSPY pinpointed dramatically high volume of redundancies in programs that were optimization targets for decades, such as SPEC CPU2006 suite, Rodinia benchmark, and NWChem---a production computational chemistry code. Guided by REDSPY, we were able to eliminate redundancies that resulted in significant speedups.},
 acmid = {3037729},
 address = {New York, NY, USA},
 author = {Wen, Shasha and Chabbi, Milind and Liu, Xu},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037729},
 isbn = {978-1-4503-4465-4},
 keyword = {approximate computing, cctlib, performance tools, pin, redundancy detection and elimination, value profiling},
 link = {http://doi.acm.org/10.1145/3037697.3037729},
 location = {Xi'an, China},
 numpages = {15},
 pages = {47--61},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {REDSPY: Exploring Value Locality in Software},
 year = {2017}
}


@article{Bhattacharjee:2017:TP:3093336.3037705,
 abstract = {We propose translation-enabled memory prefetching optimizations or TEMPO, a low-overhead hardware mechanism to boost memory performance by exploiting the operating system's (OS) virtual memory subsystem. We are the first to make the following observations: (1) a substantial fraction (20-40%) of DRAM references in modern big- data workloads are devoted to accessing page tables; and (2) when memory references require page table lookups in DRAM, the vast majority of them (98%+) also look up DRAM for the subsequent data access. TEMPO exploits these observations to enable DRAM row-buffer and on-chip cache prefetching of the data that page tables point to. TEMPO requires trivial changes to the memory controller (under 3% additional area), no OS or application changes, and improves performance by 10-30% and energy by 1-14%.},
 acmid = {3037705},
 address = {New York, NY, USA},
 author = {Bhattacharjee, Abhishek},
 doi = {10.1145/3093336.3037705},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {cache prefetching, dram., virtual memory},
 link = {http://doi.acm.org/10.1145/3093336.3037705},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {63--76},
 publisher = {ACM},
 title = {Translation-Triggered Prefetching},
 volume = {52},
 year = {2017}
}


@article{Barbalace:2017:BBH:3093336.3037738,
 abstract = {Energy efficiency is one of the most important design considerations in running modern datacenters. Datacenter operating systems rely on software techniques such as execution migration to achieve energy efficiency across pools of machines. Execution migration is possible in datacenters today because they consist mainly of homogeneous-ISA machines. However, recent market trends indicate that alternate ISAs such as ARM and PowerPC are pushing into the datacenter, meaning current execution migration techniques are no longer applicable. How can execution migration be applied in future heterogeneous-ISA datacenters? In this work we present a compiler, runtime, and an operating system extension for enabling execution migration between heterogeneous-ISA servers. We present a new multi-ISA binary architecture and heterogeneous-OS containers for facilitating efficient migration of natively-compiled applications. We build and evaluate a prototype of our design and demonstrate energy savings of up to 66% for a workload running on an ARM and an x86 server interconnected by a high-speed network.},
 acmid = {3037738},
 address = {New York, NY, USA},
 author = {Barbalace, Antonio and Lyerly, Robert and Jelesnianski, Christopher and Carno, Anthony and Chuang, Ho-Ren and Legout, Vincent and Ravindran, Binoy},
 doi = {10.1145/3093336.3037738},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {compilers, heterogeneous isas, process migration, replicated-kernel os, state transformation},
 link = {http://doi.acm.org/10.1145/3093336.3037738},
 month = {apr},
 number = {4},
 numpages = {15},
 pages = {645--659},
 publisher = {ACM},
 title = {Breaking the Boundaries in Heterogeneous-ISA Datacenters},
 volume = {52},
 year = {2017}
}


@inproceedings{Lustig:2017:ASC:3037697.3037723,
 abstract = {The memory consistency model is a fundamental part of any shared memory architecture or programming model. Modern weak memory models are notoriously difficult to define and to implement correctly. Most real-world programming languages, compilers, and (micro)architectures therefore rely heavily on black-box testing methodologies. The success of such techniques requires that the suite of litmus tests used to perform the testing be comprehensive--it should ideally stress all obscure corner cases of the model and of its implementation. Most litmus test suites today are generated from some combination of manual effort and randomization; however, the complex and subtle nature of contemporary memory models means that manual effort is both error-prone and subject to incomplete coverage. This paper presents a methodology for synthesizing comprehensive litmus test suites directly from a memory model specification. By construction, these suites contain all tests satisfying a minimality criterion: that no synchronization mechanism in the test can be weakened without causing new behaviors to become observable. We formalize this notion using the Alloy modeling language, and we apply it to a number of existing and newly-proposed memory models. Our results show not only that this synthesis technique can automatically reproduce all manually-generated tests from existing suites, but also that it discovers new tests that are not as well studied.},
 acmid = {3037723},
 address = {New York, NY, USA},
 author = {Lustig, Daniel and Wright, Andrew and Papakonstantinou, Alexandros and Giroux, Olivier},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037723},
 isbn = {978-1-4503-4465-4},
 keyword = {litmus tests, memory consistency models, synchronization, synthesis},
 link = {http://doi.acm.org/10.1145/3037697.3037723},
 location = {Xi'an, China},
 numpages = {15},
 pages = {661--675},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Automated Synthesis of Comprehensive Memory Model Litmus Test Suites},
 year = {2017}
}


@inproceedings{Mashtizadeh:2017:TPD:3037697.3037751,
 abstract = {We present Castor, a record/replay system for multi-core applications that provides consistently low and predictable overheads. With Castor, developers can leave record and replay on by default, making it practical to record and reproduce production bugs, or employ fault tolerance to recover from hardware failures. Castor is inspired by several observations: First, an efficient mechanism for logging non-deterministic events is critical for recording demanding workloads with low overhead. Through careful use of hardware we were able to increase log throughput by 10x or more, e.g., we could record a server handling 10x more requests per second for the same record overhead. Second, most applications can be recorded without modifying source code by using the compiler to instrument language level sources of non-determinism, in conjunction with more familiar techniques like shared library interposition. Third, while Castor cannot deterministically replay all data races, this limitation is generally unimportant in practice, contrary to what prior work has assumed. Castor currently supports applications written in C, C++, and Go on FreeBSD. We have evaluated Castor on parallel and server workloads, including a commercial implementation of memcached in Go, which runs Castor in production.},
 acmid = {3037751},
 address = {New York, NY, USA},
 author = {Mashtizadeh, Ali Jos{\'e} and Garfinkel, Tal and Terei, David and Mazieres, David and Rosenblum, Mendel},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037751},
 isbn = {978-1-4503-4465-4},
 keyword = {fault-tolerance, multi-core replay, replay debugging},
 link = {http://doi.acm.org/10.1145/3037697.3037751},
 location = {Xi'an, China},
 numpages = {16},
 pages = {693--708},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Towards Practical Default-On Multi-Core Record/Replay},
 year = {2017}
}


@inproceedings{Vora:2017:CCR:3037697.3037747,
 abstract = {Existing distributed asynchronous graph processing systems employ checkpointing to capture globally consistent snapshots and rollback all machines to most recent checkpoint to recover from machine failures. In this paper we argue that recovery in distributed asynchronous graph processing does not require the entire execution state to be rolled back to a globally consistent state due to the relaxed asynchronous execution semantics. We define the properties required in the recovered state for it to be usable for correct asynchronous processing and develop CoRAL, a lightweight checkpointing and recovery algorithm. First, this algorithm carries out confined recovery that only rolls back graph execution states of the failed machines to affect recovery. Second, it relies upon lightweight checkpoints that capture locally consistent snapshots with a reduced peak network bandwidth requirement. Our experiments using real-world graphs show that our technique recovers from failures and finishes processing 1.5x to 3.2x faster compared to the traditional asynchronous checkpointing and recovery mechanism when failures impact 1 to 6 machines of a 16 machine cluster. Moreover, capturing locally consistent snapshots significantly reduces intermittent high peak bandwidth usage required to save the snapshots -- the average reduction in 99th percentile bandwidth ranges from 22% to 51% while 1 to 6 snapshot replicas are being maintained.},
 acmid = {3037747},
 address = {New York, NY, USA},
 author = {Vora, Keval and Tian, Chen and Gupta, Rajiv and Hu, Ziang},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037747},
 isbn = {978-1-4503-4465-4},
 keyword = {distributed processing, fault tolerance, graph processing},
 link = {http://doi.acm.org/10.1145/3037697.3037747},
 location = {Xi'an, China},
 numpages = {14},
 pages = {223--236},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {CoRAL: Confined Recovery in Distributed Asynchronous Graph Processing},
 year = {2017}
}


@article{Bai:2017:VRE:3093336.3037717,
 abstract = {Conventional off-chip voltage regulators are typically bulky and slow, and are inefficient at exploiting system and workload variability using Dynamic Voltage and Frequency Scaling (DVFS). On-die integration of voltage regulators has the potential to increase the energy efficiency of computer systems by enabling power control at a fine granularity in both space and time. The energy conversion efficiency of on-chip regulators, however, is typically much lower than off-chip regulators, which results in significant energy losses. Fine-grained power control and high voltage regulator efficiency are difficult to achieve simultaneously, with either emerging on-chip or conventional off-chip regulators. A voltage conversion framework that relies on a hierarchy of off-chip switching regulators and on-chip linear regulators is proposed to enable fine-grained power control with a regulator efficiency greater than 90%. A DVFS control policy that is based on a reinforcement learning (RL) approach is developed to exploit the proposed framework. Per-core RL agents learn and improve their control policies independently, while retaining the ability to coordinate their actions to accomplish system level power management objectives. When evaluated on a mix of 14 parallel and 13 multiprogrammed workloads, the proposed voltage conversion framework achieves 18% greater energy efficiency than a conventional framework that uses on-chip switching regulators. Moreover, when the RL based DVFS control policy is used to control the proposed voltage conversion framework, the system achieves a 21% higher energy efficiency over a baseline oracle policy with coarse-grained power control capability.},
 acmid = {3037717},
 address = {New York, NY, USA},
 author = {Bai, Yuxin and Lee, Victor W. and Ipek, Engin},
 doi = {10.1145/3093336.3037717},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {computer architecture, energy, power, thermal management},
 link = {http://doi.acm.org/10.1145/3093336.3037717},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {825--838},
 publisher = {ACM},
 title = {Voltage Regulator Efficiency Aware Power Management},
 volume = {52},
 year = {2017}
}


@inproceedings{Agarwal:2017:TAP:3037697.3037706,
 abstract = {The advent of new memory technologies that are denser and cheaper than commodity DRAM has renewed interest in two-tiered main memory schemes. Infrequently accessed application data can be stored in such memories to achieve significant memory cost savings. Past research on two-tiered main memory has assumed a 4KB page size. However, 2MB huge pages are performance critical in cloud applications with large memory footprints, especially in virtualized cloud environments, where nested paging drastically increases the cost of 4KB page management. We present Thermostat, an application-transparent huge-page-aware mechanism to place pages in a dual-technology hybrid memory system while achieving both the cost advantages of two-tiered memory and performance advantages of transparent huge pages. We present an online page classification mechanism that accurately classifies both 4KB and 2MB pages as hot or cold while incurring no observable performance overhead across several representative cloud applications. We implement Thermostat in Linux kernel version 4.5 and evaluate its effectiveness on representative cloud computing workloads running under KVM virtualization. We emulate slow memory with performance characteristics approximating near-future high-density memory technology and show that Thermostat migrates up to 50% of application footprint to slow memory while limiting performance degradation to 3%, thereby reducing memory cost up to 30%.},
 acmid = {3037706},
 address = {New York, NY, USA},
 author = {Agarwal, Neha and Wenisch, Thomas F.},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037706},
 isbn = {978-1-4503-4465-4},
 keyword = {cloud computing, operating systems},
 link = {http://doi.acm.org/10.1145/3037697.3037706},
 location = {Xi'an, China},
 numpages = {14},
 pages = {631--644},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Thermostat: Application-transparent Page Management for Two-tiered Main Memory},
 year = {2017}
}


@inproceedings{Kim:2017:TAA:3037697.3037726,
 abstract = {Dynamic scripting languages are becoming more and more widely adopted not only for fast prototyping but also for developing production-grade applications. They provide high-productivity programming environments featuring high levels of abstraction with powerful built-in functions, automatic memory management, object-oriented programming paradigm and dynamic typing. However, their flexible, dynamic type systems easily become the source of inefficiency in terms of instruction count, memory footprint, and energy consumption. This overhead makes it challenging to deploy these high-productivity programming technologies on emerging single-board computers for IoT applications. Addressing this challenge, this paper introduces Typed Architectures, a high-efficiency, low-cost execution substrate for dynamic scripting languages, where each data variable retains high-level type information at an ISA level. Typed Architectures calculate and check the dynamic type of each variable implicitly in hardware, rather than explicitly in software, hence significantly reducing instruction count for dynamic type checking. Besides, Typed Architectures introduce polymorphic instructions (e.g., xadd), which are bound to the correct native instruction at runtime within the pipeline (e.g., add or fadd) to efficiently implement polymorphic operators. Finally, Typed Architectures provide hardware support for flexible yet efficient type tag extraction and insertion, capturing common data layout patterns of tag-value pairs. Our evaluation using a fully synthesizable RISC-V RTL design on FPGA shows that Typed Architectures achieve geomean speedups of 11.2% and 9.9% with maximum speedups of 32.6% and 43.5% for two production-grade scripting engines for JavaScript and Lua, respectively. Moreover, Typed Architectures improve the energy-delay product (EDP) by 19.3% for JavaScript and 16.5% for Lua with an area overhead of 1.6% at a 40nm technology node.},
 acmid = {3037726},
 address = {New York, NY, USA},
 author = {Kim, Channoh and Kim, Jaehyeok and Kim, Sungmin and Kim, Dooyoung and Kim, Namho and Na, Gitae and Oh, Young H. and Cho, Hyeon Gyu and Lee, Jae W.},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 doi = {10.1145/3037697.3037726},
 isbn = {978-1-4503-4465-4},
 keyword = {instruction set architecture, internet of things (iot), interpreters, javascript, lua, microarchitecture, performance, pipeline, scripting languages, type checking},
 link = {http://doi.acm.org/10.1145/3037697.3037726},
 location = {Xi'an, China},
 numpages = {14},
 pages = {77--90},
 publisher = {ACM},
 series = {ASPLOS '17},
 title = {Typed Architectures: Architectural Support for Lightweight Scripting},
 year = {2017}
}


@article{Kang:2017:NCI:3093337.3037698,
 abstract = {The computation for today's intelligent personal assistants such as Apple Siri, Google Now, and Microsoft Cortana, is performed in the cloud. This cloud-only approach requires significant amounts of data to be sent to the cloud over the wireless network and puts significant computational pressure on the datacenter. However, as the computational resources in mobile devices become more powerful and energy efficient, questions arise as to whether this cloud-only processing is desirable moving forward, and what are the implications of pushing some or all of this compute to the mobile devices on the edge. In this paper, we examine the status quo approach of cloud-only processing and investigate computation partitioning strategies that effectively leverage both the cycles in the cloud and on the mobile device to achieve low latency, low energy consumption, and high datacenter throughput for this class of intelligent applications. Our study uses 8 intelligent applications spanning computer vision, speech, and natural language domains, all employing state-of-the-art Deep Neural Networks (DNNs) as the core machine learning technique. We find that given the characteristics of DNN algorithms, a fine-grained, layer-level computation partitioning strategy based on the data and computation variations of each layer within a DNN has significant latency and energy advantages over the status quo approach. Using this insight, we design Neurosurgeon, a lightweight scheduler to automatically partition DNN computation between mobile devices and datacenters at the granularity of neural network layers. Neurosurgeon does not require per-application profiling. It adapts to various DNN architectures, hardware platforms, wireless networks, and server load levels, intelligently partitioning computation for best latency or best mobile energy. We evaluate Neurosurgeon on a state-of-the-art mobile development platform and show that it improves end-to-end latency by 3.1X on average and up to 40.7X, reduces mobile energy consumption by 59.5% on average and up to 94.7%, and improves datacenter throughput by 1.5X on average and up to 6.7X.},
 acmid = {3037698},
 address = {New York, NY, USA},
 author = {Kang, Yiping and Hauswald, Johann and Gao, Cao and Rovinski, Austin and Mudge, Trevor and Mars, Jason and Tang, Lingjia},
 doi = {10.1145/3093337.3037698},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {cloud computing, deep neural networks, intelligent applications, mobile computing},
 link = {http://doi.acm.org/10.1145/3093337.3037698},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {615--629},
 publisher = {ACM},
 title = {Neurosurgeon: Collaborative Intelligence Between the Cloud and Mobile Edge},
 volume = {45},
 year = {2017}
}


@article{Akturk:2017:AAA:3093336.3037741,
 abstract = {Due to imbalances in technology scaling, the energy consumption of data storage and communication by far exceeds the energy consumption of actual data production, i.e., computation. As a consequence, recomputing data can become more energy efficient than storing and retrieving precomputed data. At the same time, recomputation can relax the pressure on the memory hierarchy and the communication bandwidth. This study hence assesses the energy efficiency prospects of trading computation for communication. We introduce an illustrative proof-of-concept design, identify practical limitations, and provide design guidelines.},
 acmid = {3037741},
 address = {New York, NY, USA},
 author = {Akturk, Ismail and Karpuzcu, Ulya R.},
 doi = {10.1145/3093336.3037741},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {energy efficiency, recomputation},
 link = {http://doi.acm.org/10.1145/3093336.3037741},
 month = {apr},
 number = {4},
 numpages = {14},
 pages = {811--824},
 publisher = {ACM},
 title = {AMNESIAC: Amnesic Automatic Computer},
 volume = {52},
 year = {2017}
}


@article{Klimovic:2017:RRF:3093336.3037732,
 abstract = {Remote access to NVMe Flash enables flexible scaling and high utilization of Flash capacity and IOPS within a datacenter. However, existing systems for remote Flash access either introduce significant performance overheads or fail to isolate the multiple remote clients sharing each Flash device. We present ReFlex, a software-based system for remote Flash access, that provides nearly identical performance to accessing local Flash. ReFlex uses a dataplane kernel to closely integrate networking and storage processing to achieve low latency and high throughput at low resource requirements. Specifically, ReFlex can serve up to 850K IOPS per core over TCP/IP networking, while adding 21us over direct access to local Flash. ReFlex uses a QoS scheduler that can enforce tail latency and throughput service-level objectives (SLOs) for thousands of remote clients. We show that ReFlex allows applications to use remote Flash while maintaining their original performance with local Flash.},
 acmid = {3037732},
 address = {New York, NY, USA},
 author = {Klimovic, Ana and Litz, Heiner and Kozyrakis, Christos},
 doi = {10.1145/3093336.3037732},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {datacenter storage, flash, i/o scheduling, network storage, qos},
 link = {http://doi.acm.org/10.1145/3093336.3037732},
 month = {apr},
 number = {4},
 numpages = {15},
 pages = {345--359},
 publisher = {ACM},
 title = {ReFlex: Remote Flash \&\#8776; Local Flash},
 volume = {52},
 year = {2017}
}


@article{Trippel:2017:TMM:3093336.3037719,
 abstract = {Memory consistency models (MCMs) which govern inter-module interactions in a shared memory system, are a significant, yet often under-appreciated, aspect of system design. MCMs are defined at the various layers of the hardware-software stack, requiring thoroughly verified specifications, compilers, and implementations at the interfaces between layers. Current verification techniques evaluate segments of the system stack in isolation, such as proving compiler mappings from a high-level language (HLL) to an ISA or proving validity of a microarchitectural implementation of an ISA. This paper makes a case for full-stack MCM verification and provides a toolflow, TriCheck, capable of verifying that the HLL, compiler, ISA, and implementation collectively uphold MCM requirements. The work showcases TriCheck's ability to evaluate a proposed ISA MCM in order to ensure that each layer and each mapping is correct and complete. Specifically, we apply TriCheck to the open source RISC-V ISA [55], seeking to verify accurate, efficient, and legal compilations from C11. We uncover under-specifications and potential inefficiencies in the current RISC-V ISA documentation and identify possible solutions for each. As an example, we find that a RISC-V-compliant microarchitecture allows 144 outcomes forbidden by C11 to be observed out of 1,701 litmus tests examined. Overall, this paper demonstrates the necessity of full-stack verification for detecting MCM-related bugs in the hardware-software stack.},
 acmid = {3037719},
 address = {New York, NY, USA},
 author = {Trippel, Caroline and Manerkar, Yatin A. and Lustig, Daniel and Pellauer, Michael and Martonosi, Margaret},
 doi = {10.1145/3093336.3037719},
 issn = {0362-1340},
 issue_date = {April 2017},
 journal = {SIGPLAN Not.},
 keyword = {here, keywords, separated by semi-colons},
 link = {http://doi.acm.org/10.1145/3093336.3037719},
 month = {apr},
 number = {4},
 numpages = {15},
 pages = {119--133},
 publisher = {ACM},
 title = {TriCheck: Memory Model Verification at the Trisection of Software, Hardware, and ISA},
 volume = {52},
 year = {2017}
}


@article{Delimitrou:2017:BIK:3093337.3037703,
 abstract = {Cloud providers routinely schedule multiple applications per physical host to increase efficiency. The resulting interference on shared resources often leads to performance degradation and, more importantly, security vulnerabilities. Interference can leak important information ranging from a service's placement to confidential data, like private keys. We present Bolt, a practical system that accurately detects the type and characteristics of applications sharing a cloud platform based on the interference an adversary sees on shared resources. Bolt leverages online data mining techniques that only require 2-5 seconds for detection. In a multi-user study on EC2, Bolt correctly identifies the characteristics of 385 out of 436 diverse workloads. Extracting this information enables a wide spectrum of previously-impractical cloud attacks, including denial of service attacks (DoS) that increase tail latency by 140x, as well as resource freeing (RFA) and co-residency attacks. Finally, we show that while advanced isolation mechanisms, such as cache partitioning lower detection accuracy, they are insufficient to eliminate these vulnerabilities altogether. To do so, one must either disallow core sharing, or only allow it between threads of the same application, leading to significant inefficiencies and performance penalties.},
 acmid = {3037703},
 address = {New York, NY, USA},
 author = {Delimitrou, Christina and Kozyrakis, Christos},
 doi = {10.1145/3093337.3037703},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {cloud computing, data mining, datacenter, denial of service attack, interference, isolation, latency, security},
 link = {http://doi.acm.org/10.1145/3093337.3037703},
 month = {apr},
 number = {1},
 numpages = {15},
 pages = {599--613},
 publisher = {ACM},
 title = {Bolt: I Know What You Did Last Summer... In The Cloud},
 volume = {45},
 year = {2017}
}


@article{Zhang:2017:ISC:3093337.3037734,
 abstract = {We present a methodology for identifying security critical properties for use in the dynamic verification of a processor. Such verification has been shown to be an effective way to prevent exploits of vulnerabilities in the processor, given a meaningful set of security properties. We use known processor errata to establish an initial set of security-critical invariants of the processor. We then use machine learning to infer an additional set of invariants that are not tied to any particular, known vulnerability, yet are critical to security. We build a tool chain implementing the approach and evaluate it for the open-source OR1200 RISC processor. We find that our tool can identify 19 (86.4%) of the 22 manually crafted security-critical properties from prior work and generates 3 new security properties not covered in prior work.},
 acmid = {3037734},
 address = {New York, NY, USA},
 author = {Zhang, Rui and Stanley, Natalie and Griggs, Christopher and Chi, Andrew and Sturton, Cynthia},
 doi = {10.1145/3093337.3037734},
 issn = {0163-5964},
 issue_date = {March 2017},
 journal = {SIGARCH Comput. Archit. News},
 keyword = {hardware security, processor errata, security properties, supervised learning},
 link = {http://doi.acm.org/10.1145/3093337.3037734},
 month = {apr},
 number = {1},
 numpages = {14},
 pages = {541--554},
 publisher = {ACM},
 title = {Identifying Security Critical Properties for the Dynamic Verification of a Processor},
 volume = {45},
 year = {2017}
}


